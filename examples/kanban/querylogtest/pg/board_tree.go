//go:build !ignore_autogenerated

// Code generated by snapsql. DO NOT EDIT.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pg

import (
	"context"
	"fmt"
	"github.com/shibukawa/snapsql"
	"time"

	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common/types"
	"github.com/google/cel-go/common/types/ref"
	"github.com/shibukawa/snapsql/langs/snapsqlgo"
)

type BoardTreeResultListsCards struct {
	ID          *int      `json:"id"`
	ListID      int       `json:"list_id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Position    float64   `json:"position"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}
type BoardTreeResultLists struct {
	ID         *int                         `json:"id"`
	BoardID    int                          `json:"board_id"`
	Name       string                       `json:"name"`
	StageOrder int                          `json:"stage_order"`
	Position   float64                      `json:"position"`
	IsArchived int                          `json:"is_archived"`
	CreatedAt  time.Time                    `json:"created_at"`
	UpdatedAt  time.Time                    `json:"updated_at"`
	Cards      []*BoardTreeResultListsCards `json:"cards"`
}

// BoardTreeResult represents the response structure for BoardTree
type BoardTreeResult struct {
	ID         *int                    `json:"id"`
	Name       string                  `json:"name"`
	Status     string                  `json:"status"`
	ArchivedAt *time.Time              `json:"archived_at"`
	CreatedAt  time.Time               `json:"created_at"`
	UpdatedAt  time.Time               `json:"updated_at"`
	Lists      []*BoardTreeResultLists `json:"lists"`
}

// BoardTree specific CEL programs and mock path
var (
	boardTreePrograms []cel.Program
)

const boardTreeMockPath = ""

func init() {
	// Static accessor functions for each type
	boardtreeresultlistsBoardIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.BoardID)
	}
	boardtreeresultlistsCardsAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.Cards)
	}
	boardtreeresultlistsCreatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.CreatedAt)
	}
	boardtreeresultlistsIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.ID)
	}
	boardtreeresultlistsIsArchivedAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.IsArchived)
	}
	boardtreeresultlistsNameAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.Name)
	}
	boardtreeresultlistsPositionAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.Position)
	}
	boardtreeresultlistsStageOrderAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.StageOrder)
	}
	boardtreeresultlistsUpdatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.UpdatedAt)
	}
	boardtreeresultlistscardsCreatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.CreatedAt)
	}
	boardtreeresultlistscardsDescriptionAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.Description)
	}
	boardtreeresultlistscardsIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.ID)
	}
	boardtreeresultlistscardsListIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.ListID)
	}
	boardtreeresultlistscardsPositionAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.Position)
	}
	boardtreeresultlistscardsTitleAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.Title)
	}
	boardtreeresultlistscardsUpdatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.UpdatedAt)
	}

	// Create type definitions for local type store
	typeDefinitions := map[string]map[string]snapsqlgo.FieldInfo{
		"BoardTreeResultLists": {
			"board_id": snapsqlgo.CreateFieldInfo(
				"board_id",
				types.IntType,
				boardtreeresultlistsBoardIDAccessor,
			),
			"cards": snapsqlgo.CreateFieldInfo(
				"cards",
				types.NewListType(types.NewObjectType("BoardTreeResultListsCards")),
				boardtreeresultlistsCardsAccessor,
			),
			"created_at": snapsqlgo.CreateFieldInfo(
				"created_at",
				types.TimestampType,
				boardtreeresultlistsCreatedAtAccessor,
			),
			"id": snapsqlgo.CreateFieldInfo(
				"id",
				types.IntType,
				boardtreeresultlistsIDAccessor,
			),
			"is_archived": snapsqlgo.CreateFieldInfo(
				"is_archived",
				types.IntType,
				boardtreeresultlistsIsArchivedAccessor,
			),
			"name": snapsqlgo.CreateFieldInfo(
				"name",
				types.StringType,
				boardtreeresultlistsNameAccessor,
			),
			"position": snapsqlgo.CreateFieldInfo(
				"position",
				types.DoubleType,
				boardtreeresultlistsPositionAccessor,
			),
			"stage_order": snapsqlgo.CreateFieldInfo(
				"stage_order",
				types.IntType,
				boardtreeresultlistsStageOrderAccessor,
			),
			"updated_at": snapsqlgo.CreateFieldInfo(
				"updated_at",
				types.TimestampType,
				boardtreeresultlistsUpdatedAtAccessor,
			),
		},
		"BoardTreeResultListsCards": {
			"created_at": snapsqlgo.CreateFieldInfo(
				"created_at",
				types.TimestampType,
				boardtreeresultlistscardsCreatedAtAccessor,
			),
			"description": snapsqlgo.CreateFieldInfo(
				"description",
				types.StringType,
				boardtreeresultlistscardsDescriptionAccessor,
			),
			"id": snapsqlgo.CreateFieldInfo(
				"id",
				types.IntType,
				boardtreeresultlistscardsIDAccessor,
			),
			"list_id": snapsqlgo.CreateFieldInfo(
				"list_id",
				types.IntType,
				boardtreeresultlistscardsListIDAccessor,
			),
			"position": snapsqlgo.CreateFieldInfo(
				"position",
				types.DoubleType,
				boardtreeresultlistscardsPositionAccessor,
			),
			"title": snapsqlgo.CreateFieldInfo(
				"title",
				types.StringType,
				boardtreeresultlistscardsTitleAccessor,
			),
			"updated_at": snapsqlgo.CreateFieldInfo(
				"updated_at",
				types.TimestampType,
				boardtreeresultlistscardsUpdatedAtAccessor,
			),
		},
	}

	// Create and set up local type store
	registry := snapsqlgo.NewLocalTypeRegistry()
	for typeName, fields := range typeDefinitions {
		registry.RegisterStructWithFields(typeName, fields)
	}

	// Set global registry for nested type resolution
	snapsqlgo.SetGlobalRegistry(registry)

	// CEL environments based on intermediate format
	celEnvironments := make([]*cel.Env, 1)
	// Environment 0 (container: root)
	{
		// Build CEL env options
		opts := []cel.EnvOption{
			cel.Container("root"),
		}
		opts = append(opts, cel.Variable("board_id", cel.IntType))
		opts = append(opts, cel.Variable("board_id", cel.IntType))
		opts = append(opts,
			cel.HomogeneousAggregateLiterals(),
			cel.EagerlyValidateDeclarations(true),
			snapsqlgo.DecimalLibrary,
		)
		opts = append(opts, snapsqlgo.CreateCELOptionsWithTypes(typeDefinitions)...)
		env0, err := cel.NewEnv(opts...)
		if err != nil {
			panic(fmt.Sprintf("failed to create BoardTree CEL environment 0: %v", err))
		}
		celEnvironments[0] = env0
	}

	// Create programs for each expression using the corresponding environment
	boardTreePrograms = make([]cel.Program, 1)
	// expr_001: "board_id" using environment 0
	{
		ast, issues := celEnvironments[0].Compile("board_id")
		if issues != nil && issues.Err() != nil {
			panic(fmt.Sprintf("failed to compile CEL expression %q: %v", "board_id", issues.Err()))
		}
		program, err := celEnvironments[0].Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program for %q: %v", "board_id", err))
		}
		boardTreePrograms[0] = program
	}
}

// BoardTree Returns a denormalised tree of a board, including all non-archived lists and their cards. Nested column aliases follow the SnapSQL hierarchy convention.
func BoardTree(ctx context.Context, executor snapsqlgo.DBExecutor, boardID int, opts ...snapsqlgo.FuncOpt) (BoardTreeResult, error) {
	var result BoardTreeResult

	// Hierarchical metas (for nested aggregation code generation - placeholder)
	// Count: 2

	funcConfig := snapsqlgo.GetFunctionConfig(ctx, "boardTree", "boardtreeresult")
	// Check for mock mode
	if funcConfig != nil && len(funcConfig.MockDataNames) > 0 {
		mockData, err := snapsqlgo.GetMockDataFromFiles(boardTreeMockPath, funcConfig.MockDataNames)
		if err != nil {
			return result, fmt.Errorf("BoardTree: failed to get mock data: %w", err)
		}

		result, err = snapsqlgo.MapMockDataToStruct[BoardTreeResult](mockData)
		if err != nil {
			return result, fmt.Errorf("BoardTree: failed to map mock data to BoardTreeResult struct: %w", err)
		}

		return result, nil
	}

	execCtx := snapsqlgo.ExtractExecutionContext(ctx)
	rowLockMode := snapsqlgo.RowLockNone
	if execCtx != nil {
		rowLockMode = execCtx.RowLockMode()
	}
	if rowLockMode != snapsqlgo.RowLockNone {
		snapsqlgo.EnsureRowLockAllowed(snapsqlgo.QueryLogQueryTypeSelect, rowLockMode)
	}
	rowLockClause := ""
	if rowLockMode != snapsqlgo.RowLockNone {
		var rowLockErr error
		rowLockClause, rowLockErr = snapsqlgo.BuildRowLockClause("postgres", rowLockMode)
		if rowLockErr != nil {
			panic(rowLockErr)
		}
	}
	queryLogOptions := snapsqlgo.QueryOptionsSnapshot{
		RowLockClause: rowLockClause,
		RowLockMode:   rowLockMode,
	}
	logger := execCtx.QueryLogger()
	defer logger.Write(ctx, func() (snapsqlgo.QueryLogMetadata, snapsqlgo.DBExecutor) {
		return snapsqlgo.QueryLogMetadata{
			FuncName:   "BoardTree",
			SourceFile: "pg/BoardTree",
			Dialect:    "postgres",
			QueryType:  snapsqlgo.QueryLogQueryTypeSelect,
			Options:    queryLogOptions,
		}, executor
	})

	// Build SQL
	buildQueryAndArgs := func() (string, []any, error) {
		query := "SELECT b.id, b.name, b.status, b.archived_at, b.created_at, b.updated_at, l.id AS lists__id, l.board_id AS lists__board_id, l.name AS lists__name, l.stage_order AS lists__stage_order, l.position AS lists__position, l.is_archived AS lists__is_archived, l.created_at AS lists__created_at, l.updated_at AS lists__updated_at, c.id AS lists__cards__id, c.list_id AS lists__cards__list_id, c.title AS lists__cards__title, c.description AS lists__cards__description, c.position AS lists__cards__position, c.created_at AS lists__cards__created_at, c.updated_at AS lists__cards__updated_at FROM boards b LEFT JOIN lists l ON l.board_id = b.id AND l.is_archived = 0 LEFT JOIN cards c ON c.list_id = l.id  WHERE b.id = $1  ORDER BY l.stage_order ASC, l.position ASC, c.position ASC "
		args := make([]any, 0)
		paramMap := map[string]any{
			"board_id": boardID,
		}

		evalRes0, _, err := boardTreePrograms[0].Eval(paramMap)
		if err != nil {
			return "", nil, fmt.Errorf("BoardTree: failed to evaluate expression: %w", err)
		}
		args = append(args, snapsqlgo.NormalizeNullableTimestamp(evalRes0))
		return query, args, nil
	}
	query, args, err := buildQueryAndArgs()
	if err != nil {
		logger.SetErr(err)
		return result, err
	}
	if queryLogOptions.RowLockClause != "" {
		query += queryLogOptions.RowLockClause
	}
	logger.SetQuery(query, args)
	// Execute query
	stmt, err := executor.PrepareContext(ctx, query)
	if err != nil {
		err = fmt.Errorf("BoardTree: failed to prepare statement: %w (query: %s)", err, query)
		logger.SetErr(err)
		return result, err
	}
	defer stmt.Close()
	// Execute query for hierarchical aggregation (one affinity)
	// Meta-driven hierarchical one scan
	rows, err := stmt.QueryContext(ctx, args...)
	if err != nil {
		return result, fmt.Errorf("failed to query rows: %w", err)
	}
	defer rows.Close()
	var col_id *int
	var col_name string
	var col_status string
	var col_archivedat *time.Time
	var col_createdat time.Time
	var col_updatedat time.Time
	var col_listsid *int
	var col_listsboardid *int
	var col_listsname *string
	var col_listsstageorder *int
	var col_listsposition *float64
	var col_listsisarchived *int
	var col_listscreatedat *time.Time
	var col_listsupdatedat *time.Time
	var col_listscardsid *int
	var col_listscardslistid *int
	var col_listscardstitle *string
	var col_listscardsdescription *string
	var col_listscardsposition *float64
	var col_listscardscreatedat *time.Time
	var col_listscardsupdatedat *time.Time
	var _parentMap map[string]*BoardTreeResult
	var _nodeMap_lists map[string]*BoardTreeResultLists
	var _nodeMap_lists_cards map[string]*BoardTreeResultListsCards
	for rows.Next() {
		err = rows.Scan(
			&col_id,
			&col_name,
			&col_status,
			&col_archivedat,
			&col_createdat,
			&col_updatedat,
			&col_listsid,
			&col_listsboardid,
			&col_listsname,
			&col_listsstageorder,
			&col_listsposition,
			&col_listsisarchived,
			&col_listscreatedat,
			&col_listsupdatedat,
			&col_listscardsid,
			&col_listscardslistid,
			&col_listscardstitle,
			&col_listscardsdescription,
			&col_listscardsposition,
			&col_listscardscreatedat,
			&col_listscardsupdatedat,
		)
		if err != nil {
			return result, fmt.Errorf("failed to scan row: %w", err)
		}
		var pk_parent string
		if col_id != nil {
			pk_parent = fmt.Sprintf("%v", *col_id)
		} else {
			pk_parent = "<nil>"
		}
		if _parentMap == nil {
			_parentMap = make(map[string]*BoardTreeResult)
		}
		parentObj, _okParent := _parentMap[pk_parent]
		if !_okParent {
			parentObj = &BoardTreeResult{}
			parentObj.ID = col_id
			parentObj.Name = col_name
			parentObj.Status = col_status
			parentObj.ArchivedAt = col_archivedat
			parentObj.CreatedAt = col_createdat
			parentObj.UpdatedAt = col_updatedat
			parentObj.Lists = make([]*BoardTreeResultLists, 0)
			_parentMap[pk_parent] = parentObj
		}
		_chain_parent := pk_parent
		// Node lists
		if !(col_listsid == nil) {
			_k_lists := fmt.Sprintf("%v", *col_listsid)
			if _nodeMap_lists == nil {
				_nodeMap_lists = make(map[string]*BoardTreeResultLists)
			}
			_chain_lists := _chain_parent + "|lists:" + _k_lists
			node_lists, _exists_lists := _nodeMap_lists[_chain_lists]
			if !_exists_lists {
				node_lists = &BoardTreeResultLists{}
				node_lists.ID = col_listsid
				if col_listsboardid != nil {
					node_lists.BoardID = *col_listsboardid
				}
				if col_listsname != nil {
					node_lists.Name = *col_listsname
				}
				if col_listsstageorder != nil {
					node_lists.StageOrder = *col_listsstageorder
				}
				if col_listsposition != nil {
					node_lists.Position = *col_listsposition
				}
				if col_listsisarchived != nil {
					node_lists.IsArchived = *col_listsisarchived
				}
				if col_listscreatedat != nil {
					node_lists.CreatedAt = *col_listscreatedat
				}
				if col_listsupdatedat != nil {
					node_lists.UpdatedAt = *col_listsupdatedat
				}
				node_lists.Cards = make([]*BoardTreeResultListsCards, 0)
				parentObj.Lists = append(parentObj.Lists, node_lists)
				_nodeMap_lists[_chain_lists] = node_lists
			}
			_chain_parent = _chain_lists
		}
		// Node lists__cards
		if !(col_listscardsid == nil) {
			_k_lists_cards := fmt.Sprintf("%v", *col_listscardsid)
			if _nodeMap_lists_cards == nil {
				_nodeMap_lists_cards = make(map[string]*BoardTreeResultListsCards)
			}
			_chain_lists_cards := _chain_parent + "|lists__cards:" + _k_lists_cards
			node_lists_cards, _exists_lists_cards := _nodeMap_lists_cards[_chain_lists_cards]
			if !_exists_lists_cards {
				node_lists_cards = &BoardTreeResultListsCards{}
				node_lists_cards.ID = col_listscardsid
				if col_listscardslistid != nil {
					node_lists_cards.ListID = *col_listscardslistid
				}
				if col_listscardstitle != nil {
					node_lists_cards.Title = *col_listscardstitle
				}
				if col_listscardsdescription != nil {
					node_lists_cards.Description = *col_listscardsdescription
				}
				if col_listscardsposition != nil {
					node_lists_cards.Position = *col_listscardsposition
				}
				if col_listscardscreatedat != nil {
					node_lists_cards.CreatedAt = *col_listscardscreatedat
				}
				if col_listscardsupdatedat != nil {
					node_lists_cards.UpdatedAt = *col_listscardsupdatedat
				}
				if p, ok := _nodeMap_lists[_chain_parent]; ok {
					p.Cards = append(p.Cards, node_lists_cards)
				}
				_nodeMap_lists_cards[_chain_lists_cards] = node_lists_cards
			}
			_chain_parent = _chain_lists_cards
		}
	}
	if err = rows.Err(); err != nil {
		return result, fmt.Errorf("error iterating rows: %w", err)
	}
	if len(_parentMap) == 0 {
		return result, snapsql.ErrNotFound
	}
	if len(_parentMap) > 1 {
		return result, snapsql.ErrHierarchicalMultipleParentsForOne
	}
	for _, v := range _parentMap {
		result = *v
	}

	return result, nil
}
