//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by snapsql. DO NOT EDIT.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package query

import (
	"context"
	"fmt"
	"time"

	"github.com/shibukawa/snapsql"

	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common/types"
	"github.com/google/cel-go/common/types/ref"
	"github.com/shibukawa/snapsql/langs/snapsqlgo"
)

type BoardTreeResultListsCards struct {
	ID          *int      `json:"id"`
	ListID      int       `json:"list_id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Position    float64   `json:"position"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}
type BoardTreeResultLists struct {
	ID         *int                         `json:"id"`
	BoardID    int                          `json:"board_id"`
	Name       string                       `json:"name"`
	StageOrder int                          `json:"stage_order"`
	Position   float64                      `json:"position"`
	IsArchived int                          `json:"is_archived"`
	CreatedAt  time.Time                    `json:"created_at"`
	UpdatedAt  time.Time                    `json:"updated_at"`
	Cards      []*BoardTreeResultListsCards `json:"cards"`
}

// BoardTreeResult represents the response structure for BoardTree
type BoardTreeResult struct {
	BID         *int                    `json:"b.id"`
	BName       string                  `json:"b.name"`
	BStatus     string                  `json:"b.status"`
	BArchivedAt *time.Time              `json:"b.archived_at"`
	BCreatedAt  time.Time               `json:"b.created_at"`
	BUpdatedAt  time.Time               `json:"b.updated_at"`
	Lists       []*BoardTreeResultLists `json:"lists"`
}

// BoardTree specific CEL programs and mock path
var (
	boardtreePrograms []cel.Program
)

const boardtreeMockPath = ""

func init() {
	// Static accessor functions for each type
	boardtreeresultlistsBoardIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.BoardID)
	}
	boardtreeresultlistsCardsAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.Cards)
	}
	boardtreeresultlistsCreatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.CreatedAt)
	}
	boardtreeresultlistsIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.ID)
	}
	boardtreeresultlistsIsArchivedAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.IsArchived)
	}
	boardtreeresultlistsNameAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.Name)
	}
	boardtreeresultlistsPositionAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.Position)
	}
	boardtreeresultlistsStageOrderAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.StageOrder)
	}
	boardtreeresultlistsUpdatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultLists)
		return snapsqlgo.ConvertGoValueToCEL(v.UpdatedAt)
	}
	boardtreeresultlistscardsCreatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.CreatedAt)
	}
	boardtreeresultlistscardsDescriptionAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.Description)
	}
	boardtreeresultlistscardsIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.ID)
	}
	boardtreeresultlistscardsListIDAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.ListID)
	}
	boardtreeresultlistscardsPositionAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.Position)
	}
	boardtreeresultlistscardsTitleAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.Title)
	}
	boardtreeresultlistscardsUpdatedAtAccessor := func(value any) ref.Val {
		v := value.(*BoardTreeResultListsCards)
		return snapsqlgo.ConvertGoValueToCEL(v.UpdatedAt)
	}

	// Create type definitions for local type store
	typeDefinitions := map[string]map[string]snapsqlgo.FieldInfo{
		"BoardTreeResultLists": {
			"board_id": snapsqlgo.CreateFieldInfo(
				"board_id",
				types.IntType,
				boardtreeresultlistsBoardIDAccessor,
			),
			"cards": snapsqlgo.CreateFieldInfo(
				"cards",
				types.NewListType(types.NewObjectType("BoardTreeResultListsCards")),
				boardtreeresultlistsCardsAccessor,
			),
			"created_at": snapsqlgo.CreateFieldInfo(
				"created_at",
				types.TimestampType,
				boardtreeresultlistsCreatedAtAccessor,
			),
			"id": snapsqlgo.CreateFieldInfo(
				"id",
				types.IntType,
				boardtreeresultlistsIDAccessor,
			),
			"is_archived": snapsqlgo.CreateFieldInfo(
				"is_archived",
				types.IntType,
				boardtreeresultlistsIsArchivedAccessor,
			),
			"name": snapsqlgo.CreateFieldInfo(
				"name",
				types.StringType,
				boardtreeresultlistsNameAccessor,
			),
			"position": snapsqlgo.CreateFieldInfo(
				"position",
				types.DoubleType,
				boardtreeresultlistsPositionAccessor,
			),
			"stage_order": snapsqlgo.CreateFieldInfo(
				"stage_order",
				types.IntType,
				boardtreeresultlistsStageOrderAccessor,
			),
			"updated_at": snapsqlgo.CreateFieldInfo(
				"updated_at",
				types.TimestampType,
				boardtreeresultlistsUpdatedAtAccessor,
			),
		},
		"BoardTreeResultListsCards": {
			"created_at": snapsqlgo.CreateFieldInfo(
				"created_at",
				types.TimestampType,
				boardtreeresultlistscardsCreatedAtAccessor,
			),
			"description": snapsqlgo.CreateFieldInfo(
				"description",
				types.StringType,
				boardtreeresultlistscardsDescriptionAccessor,
			),
			"id": snapsqlgo.CreateFieldInfo(
				"id",
				types.IntType,
				boardtreeresultlistscardsIDAccessor,
			),
			"list_id": snapsqlgo.CreateFieldInfo(
				"list_id",
				types.IntType,
				boardtreeresultlistscardsListIDAccessor,
			),
			"position": snapsqlgo.CreateFieldInfo(
				"position",
				types.DoubleType,
				boardtreeresultlistscardsPositionAccessor,
			),
			"title": snapsqlgo.CreateFieldInfo(
				"title",
				types.StringType,
				boardtreeresultlistscardsTitleAccessor,
			),
			"updated_at": snapsqlgo.CreateFieldInfo(
				"updated_at",
				types.TimestampType,
				boardtreeresultlistscardsUpdatedAtAccessor,
			),
		},
	}

	// Create and set up local type store
	registry := snapsqlgo.NewLocalTypeRegistry()
	for typeName, fields := range typeDefinitions {
		registry.RegisterStructWithFields(typeName, fields)
	}

	// Set global registry for nested type resolution
	snapsqlgo.SetGlobalRegistry(registry)

	// CEL environments based on intermediate format
	celEnvironments := make([]*cel.Env, 1)
	// Environment 0: Base environment
	{
		// Build CEL env options then expand variadic at call-site to avoid type inference issues
		opts := []cel.EnvOption{
			cel.HomogeneousAggregateLiterals(),
			cel.EagerlyValidateDeclarations(true),
			snapsqlgo.DecimalLibrary,
			cel.Variable("board_id", cel.IntType),
		}
		opts = append(opts, snapsqlgo.CreateCELOptionsWithTypes(typeDefinitions)...)
		env0, err := cel.NewEnv(opts...)
		if err != nil {
			panic(fmt.Sprintf("failed to create BoardTree CEL environment 0: %v", err))
		}
		celEnvironments[0] = env0
	}

	// Create programs for each expression using the corresponding environment
	boardtreePrograms = make([]cel.Program, 1)
	// expr_001: "board_id" using environment 0
	{
		ast, issues := celEnvironments[0].Compile("board_id")
		if issues != nil && issues.Err() != nil {
			panic(fmt.Sprintf("failed to compile CEL expression %q: %v", "board_id", issues.Err()))
		}
		program, err := celEnvironments[0].Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program for %q: %v", "board_id", err))
		}
		boardtreePrograms[0] = program
	}
}

// BoardTree Returns a denormalised tree of a board, including all non-archived lists and their cards. Nested column aliases follow the SnapSQL hierarchy convention.
func BoardTree(ctx context.Context, executor snapsqlgo.DBExecutor, boardID int, opts ...snapsqlgo.FuncOpt) (BoardTreeResult, error) {
	var result BoardTreeResult

	// Hierarchical metas (for nested aggregation code generation - placeholder)
	// Count: 2

	funcConfig := snapsqlgo.GetFunctionConfig(ctx, "boardtree", "boardtreeresult")
	// Check for mock mode
	if funcConfig != nil && len(funcConfig.MockDataNames) > 0 {
		mockData, err := snapsqlgo.GetMockDataFromFiles(boardtreeMockPath, funcConfig.MockDataNames)
		if err != nil {
			return result, fmt.Errorf("BoardTree: failed to get mock data: %w", err)
		}

		result, err = snapsqlgo.MapMockDataToStruct[BoardTreeResult](mockData)
		if err != nil {
			return result, fmt.Errorf("BoardTree: failed to map mock data to BoardTreeResult struct: %w", err)
		}

		return result, nil
	}

	// Build SQL
	buildQueryAndArgs := func() (string, []any, error) {
		query := "SELECT b.id, b.name, b.status, b.archived_at, b.created_at, b.updated_at, l.id AS lists__id, l.board_id AS lists__board_id, l.name AS lists__name, l.stage_order AS lists__stage_order, l.position AS lists__position, l.is_archived AS lists__is_archived, l.created_at AS lists__created_at, l.updated_at AS lists__updated_at, c.id AS lists__cards__id, c.list_id AS lists__cards__list_id, c.title AS lists__cards__title, c.description AS lists__cards__description, c.position AS lists__cards__position, c.created_at AS lists__cards__created_at, c.updated_at AS lists__cards__updated_at FROM boards b LEFT JOIN lists l ON l.board_id = b.id AND l.is_archived = 0 LEFT JOIN cards c ON c.list_id = l.id  WHERE b.id =$1 ORDER BY l.stage_order ASC, l.position ASC, c.position ASC"
		args := make([]any, 0)
		paramMap := map[string]any{
			"board_id": boardID,
		}

		evalRes0, _, err := boardtreePrograms[0].Eval(paramMap)
		if err != nil {
			return "", nil, fmt.Errorf("BoardTree: failed to evaluate expression: %w", err)
		}
		args = append(args, evalRes0.Value())
		return query, args, nil
	}
	query, args, err := buildQueryAndArgs()
	if err != nil {
		return result, err
	}
	// Execute query
	stmt, err := executor.PrepareContext(ctx, query)
	if err != nil {
		return result, fmt.Errorf("BoardTree: failed to prepare statement: %w", err)
	}
	defer stmt.Close()
	// Execute query for hierarchical aggregation (one affinity)
	// Meta-driven hierarchical one scan
	rows, err := stmt.QueryContext(ctx, args...)
	if err != nil {
		return result, fmt.Errorf("failed to query rows: %w", err)
	}
	defer rows.Close()
	var col_bid *int
	var col_bname string
	var col_bstatus string
	var col_barchivedat *time.Time
	var col_bcreatedat time.Time
	var col_bupdatedat time.Time
	var col_listsid *int
	var col_listsboardid *int
	var col_listsname *string
	var col_listsstageorder *int
	var col_listsposition *float64
	var col_listsisarchived *int
	var col_listscreatedat *time.Time
	var col_listsupdatedat *time.Time
	var col_listscardsid *int
	var col_listscardslistid *int
	var col_listscardstitle *string
	var col_listscardsdescription *string
	var col_listscardsposition *float64
	var col_listscardscreatedat *time.Time
	var col_listscardsupdatedat *time.Time
	var _parentMap map[string]*BoardTreeResult
	var _nodeMap_lists map[string]*BoardTreeResultLists
	var _nodeMap_lists_cards map[string]*BoardTreeResultListsCards
	for rows.Next() {
		err = rows.Scan(
			&col_bid,
			&col_bname,
			&col_bstatus,
			&col_barchivedat,
			&col_bcreatedat,
			&col_bupdatedat,
			&col_listsid,
			&col_listsboardid,
			&col_listsname,
			&col_listsstageorder,
			&col_listsposition,
			&col_listsisarchived,
			&col_listscreatedat,
			&col_listsupdatedat,
			&col_listscardsid,
			&col_listscardslistid,
			&col_listscardstitle,
			&col_listscardsdescription,
			&col_listscardsposition,
			&col_listscardscreatedat,
			&col_listscardsupdatedat,
		)
		if err != nil {
			return result, fmt.Errorf("failed to scan row: %w", err)
		}
		var pk_parent string
		if col_bid != nil {
			pk_parent = fmt.Sprintf("%v", *col_bid)
		} else {
			pk_parent = "<nil>"
		}
		if _parentMap == nil {
			_parentMap = make(map[string]*BoardTreeResult)
		}
		parentObj, _okParent := _parentMap[pk_parent]
		if !_okParent {
			parentObj = &BoardTreeResult{}
			parentObj.BID = col_bid
			parentObj.BName = col_bname
			parentObj.BStatus = col_bstatus
			parentObj.BArchivedAt = col_barchivedat
			parentObj.BCreatedAt = col_bcreatedat
			parentObj.BUpdatedAt = col_bupdatedat
			parentObj.Lists = make([]*BoardTreeResultLists, 0)
			_parentMap[pk_parent] = parentObj
		}
		_chain_parent := pk_parent
		// Node lists
		if !(col_listsid == nil) {
			_k_lists := fmt.Sprintf("%v", *col_listsid)
			if _nodeMap_lists == nil {
				_nodeMap_lists = make(map[string]*BoardTreeResultLists)
			}
			_chain_lists := _chain_parent + "|lists:" + _k_lists
			node_lists, _exists_lists := _nodeMap_lists[_chain_lists]
			if !_exists_lists {
				node_lists = &BoardTreeResultLists{}
				node_lists.ID = col_listsid
				if col_listsboardid != nil {
					node_lists.BoardID = *col_listsboardid
				}
				if col_listsname != nil {
					node_lists.Name = *col_listsname
				}
				if col_listsstageorder != nil {
					node_lists.StageOrder = *col_listsstageorder
				}
				if col_listsposition != nil {
					node_lists.Position = *col_listsposition
				}
				if col_listsisarchived != nil {
					node_lists.IsArchived = *col_listsisarchived
				}
				if col_listscreatedat != nil {
					node_lists.CreatedAt = *col_listscreatedat
				}
				if col_listsupdatedat != nil {
					node_lists.UpdatedAt = *col_listsupdatedat
				}
				node_lists.Cards = make([]*BoardTreeResultListsCards, 0)
				parentObj.Lists = append(parentObj.Lists, node_lists)
				_nodeMap_lists[_chain_lists] = node_lists
			}
			_chain_parent = _chain_lists
		}
		// Node lists__cards
		if !(col_listscardsid == nil) {
			_k_lists_cards := fmt.Sprintf("%v", *col_listscardsid)
			if _nodeMap_lists_cards == nil {
				_nodeMap_lists_cards = make(map[string]*BoardTreeResultListsCards)
			}
			_chain_lists_cards := _chain_parent + "|lists__cards:" + _k_lists_cards
			node_lists_cards, _exists_lists_cards := _nodeMap_lists_cards[_chain_lists_cards]
			if !_exists_lists_cards {
				node_lists_cards = &BoardTreeResultListsCards{}
				node_lists_cards.ID = col_listscardsid
				if col_listscardslistid != nil {
					node_lists_cards.ListID = *col_listscardslistid
				}
				if col_listscardstitle != nil {
					node_lists_cards.Title = *col_listscardstitle
				}
				if col_listscardsdescription != nil {
					node_lists_cards.Description = *col_listscardsdescription
				}
				if col_listscardsposition != nil {
					node_lists_cards.Position = *col_listscardsposition
				}
				if col_listscardscreatedat != nil {
					node_lists_cards.CreatedAt = *col_listscardscreatedat
				}
				if col_listscardsupdatedat != nil {
					node_lists_cards.UpdatedAt = *col_listscardsupdatedat
				}
				if p, ok := _nodeMap_lists[_chain_parent]; ok {
					p.Cards = append(p.Cards, node_lists_cards)
				}
				_nodeMap_lists_cards[_chain_lists_cards] = node_lists_cards
			}
			_chain_parent = _chain_lists_cards
		}
	}
	if err = rows.Err(); err != nil {
		return result, fmt.Errorf("error iterating rows: %w", err)
	}
	if len(_parentMap) == 0 {
		return result, snapsql.ErrNotFound
	}
	if len(_parentMap) > 1 {
		return result, snapsql.ErrHierarchicalMultipleParentsForOne
	}
	for _, v := range _parentMap {
		result = *v
	}

	return result, nil
}
