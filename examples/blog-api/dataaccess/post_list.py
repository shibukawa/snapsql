# Generated by snapsql - DO NOT EDIT
# Generated at: 2025-11-20T20:47:34+09:00
# Function: post_list
# Dialect: postgres

"""
Lists published posts with author information, supports pagination.
"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Union
from datetime import datetime
from decimal import Decimal
from .snapsql_runtime import (
    get_snapsql_context,
    ValidationError,
    NotFoundError,
    QueryLogMetadata,
    ROW_LOCK_NONE,
    ensure_row_lock_allowed,
    build_row_lock_clause_postgres,
)
# PostgreSQL async driver
try:
    import asyncpg
except ImportError:
    raise ImportError("asyncpg is required for PostgreSQL. Install with: pip install asyncpg")

# ============================================================================
# Response Structures
# ============================================================================

@dataclass
class PostListResultAuthor:
    """Response structure for post_list"""
    username: str
    full_name: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)

@dataclass
class PostListResult:
    """Response structure for post_list"""
    post_id: int
    title: str
    content: str
    author_id: int
    published: bool
    view_count: int
    created_at: datetime
    updated_at: datetime
    author: List[PostListResultAuthor] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)


# ============================================================================
# Generated Functions
# ============================================================================
async def post_list(
    conn: asyncpg.Connection,
    limit: int,
    offset: int,
) -> AsyncGenerator[PostListResult, None]:
    """
    Lists published posts with author information, supports pagination.
    
    Args:
        limit: 
        offset: 
    
    Returns:
        Result of post_list
    """
    # Validate required parameters
    if limit is None:
        raise ValidationError(
            message="Required parameter 'limit' cannot be None",
            param_name="limit",
            func_name="post_list"
        )
    if offset is None:
        raise ValidationError(
            message="Required parameter 'offset' cannot be None",
            param_name="offset",
            func_name="post_list"
        )
    
    # Build SQL
    sql = """SELECT p.post_id, p.title, p.content, p.author_id, p.published, p.view_count, p.created_at, p.updated_at, u.username as author__username, u.full_name as author__full_name FROM posts p JOIN users u ON p.author_id = u.user_id WHERE p.published = true ORDER BY p.created_at DESC  LIMIT $1 OFFSET $2 """
    args = [limit, offset]

    ctx = get_snapsql_context()
    row_lock_clause = ""
    if ctx.row_lock_mode not in (None, "", ROW_LOCK_NONE):
        ensure_row_lock_allowed("select", ctx.row_lock_mode)
        row_lock_clause = build_row_lock_clause_postgres(ctx.row_lock_mode)
        if row_lock_clause:
            sql += row_lock_clause
    logger = ctx.query_logger if ctx.enable_query_log else None
    error = None
    row_count = None
    import time
    start_time = time.time()
    try:
        # Execute query for hierarchical aggregation
        # This aggregates child records into parent objects

        rows = await conn.fetch(sql, *args)

        # Process rows for hierarchical aggregation
        current_parent = None
        current_parent_key = None

        for row in rows:
            row_dict = dict(row)
            
            # Extract parent key
            parent_key = row_dict.get('post_id')
            
            # Check if we have a new parent
            if parent_key != current_parent_key:
                # Yield previous parent if exists
                if current_parent is not None:
                    yield current_parent
                
                # Create new parent object
                current_parent = PostListResult(
                    post_id=row_dict.get('post_id'),
                    title=row_dict.get('title'),
                    content=row_dict.get('content'),
                    author_id=row_dict.get('author_id'),
                    published=row_dict.get('published'),
                    view_count=row_dict.get('view_count'),
                    created_at=row_dict.get('created_at'),
                    updated_at=row_dict.get('updated_at'),
                    author=[]
                )
                current_parent_key = parent_key
            
            # Add child objects if present
            if any([row_dict.get('author__username'), row_dict.get('author__full_name')]):
                child_obj = PostListResultAuthor(
                    username=row_dict.get('author__username'),
                    full_name=row_dict.get('author__full_name')
                )
                current_parent.author.append(child_obj)

        # Yield last parent if exists
        if current_parent is not None:
            yield current_parent
    except Exception as err:
        error = err
        raise
    finally:
        if logger:
            duration_ms = (time.time() - start_time) * 1000
            metadata = QueryLogMetadata(
                func_name="post_list",
                source_file="post_list",
                dialect="postgres",
                query_type="select"
            )
            await logger.write(metadata, duration_ms, row_count, error)
