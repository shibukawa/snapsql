# Generated by snapsql - DO NOT EDIT
# Generated at: 2025-11-20T20:47:34+09:00
# Function: user_list
# Dialect: postgres

"""
Lists all users ordered by creation date (newest first).
"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Union
from datetime import datetime
from decimal import Decimal
from .snapsql_runtime import (
    get_snapsql_context,
    QueryLogMetadata,
    ROW_LOCK_NONE,
    ensure_row_lock_allowed,
    build_row_lock_clause_postgres,
)
# PostgreSQL async driver
try:
    import asyncpg
except ImportError:
    raise ImportError("asyncpg is required for PostgreSQL. Install with: pip install asyncpg")

# ============================================================================
# Response Structures
# ============================================================================

@dataclass
class UserListResult:
    """Response structure for user_list"""
    user_id: int
    username: str
    email: str
    created_at: datetime
    updated_at: datetime
    full_name: Optional[str] = None
    bio: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)


# ============================================================================
# Generated Functions
# ============================================================================
async def user_list(
    conn: asyncpg.Connection,
) -> AsyncGenerator[UserListResult, None]:
    """
    Lists all users ordered by creation date (newest first).
    
    Args:
    
    Returns:
        Result of user_list
    """
    
    # Build SQL
    sql = """SELECT user_id, username, email, full_name, bio, created_at, updated_at FROM users ORDER BY created_at DESC """
    args = []

    ctx = get_snapsql_context()
    row_lock_clause = ""
    if ctx.row_lock_mode not in (None, "", ROW_LOCK_NONE):
        ensure_row_lock_allowed("select", ctx.row_lock_mode)
        row_lock_clause = build_row_lock_clause_postgres(ctx.row_lock_mode)
        if row_lock_clause:
            sql += row_lock_clause
    logger = ctx.query_logger if ctx.enable_query_log else None
    error = None
    row_count = None
    import time
    start_time = time.time()
    try:
        # Execute query and yield rows as async generator
        rows = await conn.fetch(sql, *args)

        # Yield each row as dataclass instance
        for row in rows:
            yield UserListResult(**dict(row))
    except Exception as err:
        error = err
        raise
    finally:
        if logger:
            duration_ms = (time.time() - start_time) * 1000
            metadata = QueryLogMetadata(
                func_name="user_list",
                source_file="user_list",
                dialect="postgres",
                query_type="select"
            )
            await logger.write(metadata, duration_ms, row_count, error)
