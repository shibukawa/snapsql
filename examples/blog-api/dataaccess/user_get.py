# Generated by snapsql - DO NOT EDIT
# Generated at: 2025-11-20T20:47:34+09:00
# Function: user_get
# Dialect: postgres

"""
Retrieves a single user by their ID.
"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Union
from datetime import datetime
from decimal import Decimal
from .snapsql_runtime import (
    get_snapsql_context,
    ValidationError,
    NotFoundError,
    QueryLogMetadata,
    ROW_LOCK_NONE,
    ensure_row_lock_allowed,
    build_row_lock_clause_postgres,
)
# PostgreSQL async driver
try:
    import asyncpg
except ImportError:
    raise ImportError("asyncpg is required for PostgreSQL. Install with: pip install asyncpg")

# ============================================================================
# Response Structures
# ============================================================================

@dataclass
class UserGetResult:
    """Response structure for user_get"""
    user_id: int
    username: str
    email: str
    created_at: datetime
    updated_at: datetime
    full_name: Optional[str] = None
    bio: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)


# ============================================================================
# Generated Functions
# ============================================================================
async def user_get(
    conn: asyncpg.Connection,
    user_id: int,
) -> UserGetResult:
    """
    Retrieves a single user by their ID.
    
    Args:
        user_id: 
    
    Returns:
        Result of user_get
    """
    # Validate required parameters
    if user_id is None:
        raise ValidationError(
            message="Required parameter 'user_id' cannot be None",
            param_name="user_id",
            func_name="user_get"
        )
    
    # Build SQL
    sql = """SELECT user_id, username, email, full_name, bio, created_at, updated_at FROM users WHERE user_id = $1 """
    args = [user_id]

    ctx = get_snapsql_context()
    row_lock_clause = ""
    if ctx.row_lock_mode not in (None, "", ROW_LOCK_NONE):
        ensure_row_lock_allowed("select", ctx.row_lock_mode)
        row_lock_clause = build_row_lock_clause_postgres(ctx.row_lock_mode)
        if row_lock_clause:
            sql += row_lock_clause
    logger = ctx.query_logger if ctx.enable_query_log else None
    error = None
    row_count = None
    import time
    start_time = time.time()
    try:
        # Execute query and fetch single row
        row = await conn.fetchrow(sql, *args)

        if row is None:
            # Build parameter dict for error message
            param_dict = {}
            # Note: args is a list, parameter names would need to be tracked separately
            raise NotFoundError(
                message="Record not found",
                func_name="user_get",
                query=sql,
                params=param_dict
            )

        # Map row to dataclass
        # asyncpg returns Record which supports dict() conversion
        return UserGetResult(**dict(row))
    except Exception as err:
        error = err
        raise
    finally:
        if logger:
            duration_ms = (time.time() - start_time) * 1000
            metadata = QueryLogMetadata(
                func_name="user_get",
                source_file="user_get",
                dialect="postgres",
                query_type="select"
            )
            await logger.write(metadata, duration_ms, row_count, error)
