# Generated by snapsql - DO NOT EDIT
# Generated at: 2025-11-20T20:47:34+09:00
# Function: post_create
# Dialect: postgres

"""
Creates a new blog post and returns the created post record.
"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Union
from datetime import datetime
from decimal import Decimal
from .snapsql_runtime import (
    get_snapsql_context,
    ValidationError,
    NotFoundError,
    QueryLogMetadata,
)
# PostgreSQL async driver
try:
    import asyncpg
except ImportError:
    raise ImportError("asyncpg is required for PostgreSQL. Install with: pip install asyncpg")

# ============================================================================
# Response Structures
# ============================================================================

@dataclass
class PostCreateResult:
    """Response structure for post_create"""
    post_id: int
    title: str
    content: str
    author_id: int
    published: bool
    view_count: int
    created_at: datetime
    updated_at: datetime
    created_by: Optional[int] = None
    updated_by: Optional[int] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)


# ============================================================================
# Generated Functions
# ============================================================================
async def post_create(
    conn: asyncpg.Connection,
    title: str,
    content: str,
    author_id: int,
    published: bool,
    created_by: int,
) -> PostCreateResult:
    """
    Creates a new blog post and returns the created post record.
    
    Args:
        title: 
        content: 
        author_id: 
        published: 
        created_by: 
    
    Returns:
        Result of post_create
    """
    # Validate required parameters
    if title is None:
        raise ValidationError(
            message="Required parameter 'title' cannot be None",
            param_name="title",
            func_name="post_create"
        )
    if content is None:
        raise ValidationError(
            message="Required parameter 'content' cannot be None",
            param_name="content",
            func_name="post_create"
        )
    if author_id is None:
        raise ValidationError(
            message="Required parameter 'author_id' cannot be None",
            param_name="author_id",
            func_name="post_create"
        )
    if published is None:
        raise ValidationError(
            message="Required parameter 'published' cannot be None",
            param_name="published",
            func_name="post_create"
        )
    if created_by is None:
        raise ValidationError(
            message="Required parameter 'created_by' cannot be None",
            param_name="created_by",
            func_name="post_create"
        )
    
    # Build SQL
    sql = """INSERT INTO posts ( title, content, author_id, published, created_by , created_at, updated_at, updated_by) VALUES ( $1, $2, $3, $4, $5 , $6, $7, $8)

RETURNING post_id, title, content, author_id, published, view_count, created_at, updated_at, created_by, updated_by"""
    args = [title, content, author_id, published, created_by, created_at, updated_at, updated_by]

    ctx = get_snapsql_context()
    logger = ctx.query_logger if ctx.enable_query_log else None
    error = None
    row_count = None
    import time
    start_time = time.time()
    try:
        # Execute query and fetch single row
        row = await conn.fetchrow(sql, *args)

        if row is None:
            # Build parameter dict for error message
            param_dict = {}
            # Note: args is a list, parameter names would need to be tracked separately
            raise NotFoundError(
                message="Record not found",
                func_name="post_create",
                query=sql,
                params=param_dict
            )

        # Map row to dataclass
        # asyncpg returns Record which supports dict() conversion
        return PostCreateResult(**dict(row))
    except Exception as err:
        error = err
        raise
    finally:
        if logger:
            duration_ms = (time.time() - start_time) * 1000
            metadata = QueryLogMetadata(
                func_name="post_create",
                source_file="post_create",
                dialect="postgres",
                query_type="insert"
            )
            await logger.write(metadata, duration_ms, row_count, error)
