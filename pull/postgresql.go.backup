package pull

import (
	"context"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

// PostgreSQLExtractor handles PostgreSQL-specific schema extraction
type PostgreSQLExtractor struct {
	*BaseExtractor
}

// NewPostgreSQLExtractor creates a new PostgreSQL extractor
func NewPostgreSQLExtractor() *PostgreSQLExtractor {
	baseExtractor, _ := NewBaseExtractor("postgresql")
	return &PostgreSQLExtractor{
		BaseExtractor: baseExtractor,
	}
}

// GetDatabaseType returns the database type
func (e *PostgreSQLExtractor) GetDatabaseType() string {
	return "postgresql"
}

// GetSystemSchemas returns PostgreSQL system schemas to exclude by default
func (e *PostgreSQLExtractor) GetSystemSchemas() []string {
	return []string{"information_schema", "pg_catalog", "pg_toast"}
}

// ExtractSchemas extracts all schemas from the database
func (e *PostgreSQLExtractor) ExtractSchemas(db any, config ExtractConfig) ([]DatabaseSchema, error) {
	// Handle both *sql.DB (for backward compatibility) and *pgxpool.Pool
	if pool, ok := db.(*pgxpool.Pool); ok {
		return e.extractSchemasFromPool(pool, config)
	}
	
	// For backward compatibility with *sql.DB
	if sqlDB, ok := db.(*sql.DB); ok {
		return e.extractSchemasFromSQLDB(sqlDB, config)
	}
	
	return nil, fmt.Errorf("unsupported database connection type")
}

	// Filter schemas
	filteredSchemas := e.FilterSystemSchemas(schemaNames, config)

	var schemas []DatabaseSchema
	for _, schemaName := range filteredSchemas {
		schema := DatabaseSchema{
			Name:         schemaName,
			ExtractedAt:  time.Now(),
			DatabaseInfo: dbInfo,
		}

		// Extract tables
		tables, err := e.ExtractTables(db, schemaName)
		if err != nil {
			return nil, err
		}
		schema.Tables = e.filterTables(tables, config)

		// Extract views if requested
		if config.IncludeViews {
			views, err := e.ExtractViews(db, schemaName)
			if err != nil {
				return nil, err
			}
			schema.Views = views
		}

		schemas = append(schemas, schema)
	}

	return schemas, nil
}

// ExtractTables extracts all tables from a specific schema
func (e *PostgreSQLExtractor) ExtractTables(db *sql.DB, schemaName string) ([]TableSchema, error) {
	query := e.BuildTablesQuery(schemaName)
	rows, err := db.Query(query)
	if err != nil {
		return nil, e.HandleDatabaseError(err)
	}
	defer rows.Close()

	var tables []TableSchema
	for rows.Next() {
		var tableName, tableOwner, comment string
		err := rows.Scan(&tableName, &tableOwner, &comment)
		if err != nil {
			return nil, e.HandleDatabaseError(err)
		}

		table := TableSchema{
			Name:    tableName,
			Schema:  schemaName,
			Comment: comment,
		}

		// Extract columns
		columns, err := e.ExtractColumns(db, schemaName, tableName)
		if err != nil {
			return nil, err
		}
		table.Columns = columns

		// Extract constraints
		constraints, err := e.ExtractConstraints(db, schemaName, tableName)
		if err != nil {
			return nil, err
		}
		table.Constraints = constraints

		// Extract indexes
		indexes, err := e.ExtractIndexes(db, schemaName, tableName)
		if err != nil {
			return nil, err
		}
		table.Indexes = indexes

		tables = append(tables, table)
	}

	return tables, nil
}

// ExtractColumns extracts all columns from a specific table
func (e *PostgreSQLExtractor) ExtractColumns(db *sql.DB, schemaName, tableName string) ([]ColumnSchema, error) {
	query := e.BuildColumnsQuery(schemaName, tableName)
	rows, err := db.Query(query)
	if err != nil {
		return nil, e.HandleDatabaseError(err)
	}
	defer rows.Close()

	var columns []ColumnSchema
	for rows.Next() {
		var columnName, dataType, isNullable string
		var columnDefault, comment sql.NullString
		var characterMaxLength, numericPrecision, numericScale sql.NullInt64

		err := rows.Scan(&columnName, &dataType, &isNullable, &columnDefault, 
			&characterMaxLength, &numericPrecision, &numericScale, &comment)
		if err != nil {
			return nil, e.HandleDatabaseError(err)
		}

		column := ColumnSchema{
			Name:        columnName,
			Type:        dataType,
			SnapSQLType: e.MapColumnType(dataType),
			Nullable:    isNullable == "YES",
		}

		if columnDefault.Valid {
			column.DefaultValue = e.ParseDefaultValue(columnDefault.String)
		}

		if comment.Valid {
			column.Comment = comment.String
		}

		columns = append(columns, column)
	}

	return columns, nil
}

// ExtractConstraints extracts all constraints from a specific table
func (e *PostgreSQLExtractor) ExtractConstraints(db *sql.DB, schemaName, tableName string) ([]ConstraintSchema, error) {
	query := e.BuildConstraintsQuery(schemaName, tableName)
	rows, err := db.Query(query)
	if err != nil {
		return nil, e.HandleDatabaseError(err)
	}
	defer rows.Close()

	constraintMap := make(map[string]*ConstraintSchema)
	
	for rows.Next() {
		var constraintName, constraintType string
		var columnName sql.NullString
		var referencedTable, referencedColumn sql.NullString

		err := rows.Scan(&constraintName, &constraintType, &columnName, 
			&referencedTable, &referencedColumn)
		if err != nil {
			return nil, e.HandleDatabaseError(err)
		}

		if constraint, exists := constraintMap[constraintName]; exists {
			// Add column to existing constraint
			if columnName.Valid {
				constraint.Columns = append(constraint.Columns, columnName.String)
			}
			if referencedColumn.Valid {
				constraint.ReferencedColumns = append(constraint.ReferencedColumns, referencedColumn.String)
			}
		} else {
			// Create new constraint
			constraint := &ConstraintSchema{
				Name: constraintName,
				Type: e.ParseConstraintType(constraintType),
			}

			if columnName.Valid {
				constraint.Columns = []string{columnName.String}
			} else {
				constraint.Columns = []string{}
			}

			if referencedTable.Valid {
				constraint.ReferencedTable = referencedTable.String
			}
			if referencedColumn.Valid {
				constraint.ReferencedColumns = []string{referencedColumn.String}
			}

			constraintMap[constraintName] = constraint
		}
	}

	// Convert map to slice
	var constraints []ConstraintSchema
	for _, constraint := range constraintMap {
		constraints = append(constraints, *constraint)
	}

	return constraints, nil
}

// ExtractIndexes extracts all indexes from a specific table
func (e *PostgreSQLExtractor) ExtractIndexes(db *sql.DB, schemaName, tableName string) ([]IndexSchema, error) {
	query := e.BuildIndexesQuery(schemaName, tableName)
	rows, err := db.Query(query)
	if err != nil {
		return nil, e.HandleDatabaseError(err)
	}
	defer rows.Close()

	var indexes []IndexSchema
	for rows.Next() {
		var indexName, indexDef string

		err := rows.Scan(&indexName, &indexDef)
		if err != nil {
			return nil, e.HandleDatabaseError(err)
		}

		index := IndexSchema{
			Name:     indexName,
			Columns:  e.ParseIndexColumns(indexDef),
			IsUnique: e.ParseIndexUnique(indexDef),
			Type:     e.ParseIndexType(indexDef),
		}

		indexes = append(indexes, index)
	}

	return indexes, nil
}

// ExtractViews extracts all views from a specific schema
func (e *PostgreSQLExtractor) ExtractViews(db *sql.DB, schemaName string) ([]ViewSchema, error) {
	query := e.BuildViewsQuery(schemaName)
	rows, err := db.Query(query)
	if err != nil {
		return nil, e.HandleDatabaseError(err)
	}
	defer rows.Close()

	var views []ViewSchema
	for rows.Next() {
		var viewName, viewDefinition string

		err := rows.Scan(&viewName, &viewDefinition)
		if err != nil {
			return nil, e.HandleDatabaseError(err)
		}

		view := ViewSchema{
			Name:       viewName,
			Schema:     schemaName,
			Definition: viewDefinition,
		}

		views = append(views, view)
	}

	return views, nil
}

// GetDatabaseInfo extracts database information
func (e *PostgreSQLExtractor) GetDatabaseInfo(db *sql.DB) (DatabaseInfo, error) {
	query := e.BuildDatabaseInfoQuery()
	row := db.QueryRow(query)

	var version, dbName, encoding string
	err := row.Scan(&version, &dbName, &encoding)
	if err != nil {
		return DatabaseInfo{}, e.HandleDatabaseError(err)
	}

	return DatabaseInfo{
		Type:    "postgresql",
		Version: e.parsePostgreSQLVersion(version),
		Name:    dbName,
		Charset: encoding,
	}, nil
}

// Query builders
func (e *PostgreSQLExtractor) BuildSchemasQuery() string {
	return `
		SELECT schema_name 
		FROM information_schema.schemata 
		WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
		  AND schema_name NOT LIKE 'pg_temp_%'
		  AND schema_name NOT LIKE 'pg_toast_temp_%'
		ORDER BY schema_name`
}

func (e *PostgreSQLExtractor) BuildTablesQuery(schemaName string) string {
	return `
		SELECT t.tablename, t.tableowner, COALESCE(obj_description(c.oid), '') as comment
		FROM pg_tables t
		LEFT JOIN pg_class c ON c.relname = t.tablename
		LEFT JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname = t.schemaname
		WHERE t.schemaname = '` + schemaName + `'
		ORDER BY t.tablename`
}

func (e *PostgreSQLExtractor) BuildColumnsQuery(schemaName, tableName string) string {
	return `
		SELECT 
			c.column_name,
			c.data_type,
			c.is_nullable,
			c.column_default,
			c.character_maximum_length,
			c.numeric_precision,
			c.numeric_scale,
			COALESCE(col_description(pgc.oid, c.ordinal_position), '') as comment
		FROM information_schema.columns c
		LEFT JOIN pg_class pgc ON pgc.relname = c.table_name
		LEFT JOIN pg_namespace pgn ON pgn.oid = pgc.relnamespace AND pgn.nspname = c.table_schema
		WHERE c.table_schema = '` + schemaName + `' AND c.table_name = '` + tableName + `'
		ORDER BY c.ordinal_position`
}

func (e *PostgreSQLExtractor) BuildConstraintsQuery(schemaName, tableName string) string {
	return `
		SELECT 
			tc.constraint_name,
			tc.constraint_type,
			kcu.column_name,
			ccu.table_name as referenced_table,
			ccu.column_name as referenced_column
		FROM information_schema.table_constraints tc
		LEFT JOIN information_schema.key_column_usage kcu 
			ON tc.constraint_name = kcu.constraint_name 
			AND tc.table_schema = kcu.table_schema
		LEFT JOIN information_schema.constraint_column_usage ccu 
			ON tc.constraint_name = ccu.constraint_name 
			AND tc.table_schema = ccu.table_schema
		WHERE tc.table_schema = '` + schemaName + `' AND tc.table_name = '` + tableName + `'
		ORDER BY tc.constraint_name, kcu.ordinal_position`
}

func (e *PostgreSQLExtractor) BuildIndexesQuery(schemaName, tableName string) string {
	return `
		SELECT indexname, indexdef
		FROM pg_indexes
		WHERE schemaname = '` + schemaName + `' AND tablename = '` + tableName + `'
		ORDER BY indexname`
}

func (e *PostgreSQLExtractor) BuildViewsQuery(schemaName string) string {
	return `
		SELECT table_name, view_definition
		FROM information_schema.views
		WHERE table_schema = '` + schemaName + `'
		ORDER BY table_name`
}

func (e *PostgreSQLExtractor) BuildDatabaseInfoQuery() string {
	return `
		SELECT 
			version() as version,
			current_database() as database_name,
			current_setting('server_encoding') as encoding`
}

// Helper methods
func (e *PostgreSQLExtractor) getSchemaNames(db *sql.DB) ([]string, error) {
	query := e.BuildSchemasQuery()
	rows, err := db.Query(query)
	if err != nil {
		return nil, e.HandleDatabaseError(err)
	}
	defer rows.Close()

	var schemas []string
	for rows.Next() {
		var schemaName string
		err := rows.Scan(&schemaName)
		if err != nil {
			return nil, e.HandleDatabaseError(err)
		}
		schemas = append(schemas, schemaName)
	}

	return schemas, nil
}

func (e *PostgreSQLExtractor) FilterSystemSchemas(schemas []string, config ExtractConfig) []string {
	systemSchemas := e.GetSystemSchemas()
	
	// Combine system schemas with user-defined excludes
	allExcludes := append(systemSchemas, config.ExcludeSchemas...)
	
	var filtered []string
	for _, schema := range schemas {
		// Also exclude pg_temp_* and pg_toast_temp_* schemas
		if strings.HasPrefix(schema, "pg_temp_") || strings.HasPrefix(schema, "pg_toast_temp_") {
			continue
		}
		
		if ShouldIncludeSchema(schema, config.IncludeSchemas, allExcludes) {
			filtered = append(filtered, schema)
		}
	}
	
	return filtered
}

func (e *PostgreSQLExtractor) filterTables(tables []TableSchema, config ExtractConfig) []TableSchema {
	var tableNames []string
	for _, table := range tables {
		tableNames = append(tableNames, table.Name)
	}
	
	filteredNames := e.FilterTables(tableNames, config)
	nameSet := make(map[string]bool)
	for _, name := range filteredNames {
		nameSet[name] = true
	}
	
	var filtered []TableSchema
	for _, table := range tables {
		if nameSet[table.Name] {
			filtered = append(filtered, table)
		}
	}
	
	return filtered
}

func (e *PostgreSQLExtractor) ParseConstraintType(pgConstraintType string) string {
	switch pgConstraintType {
	case "PRIMARY KEY":
		return "PRIMARY_KEY"
	case "FOREIGN KEY":
		return "FOREIGN_KEY"
	case "UNIQUE":
		return "UNIQUE"
	case "CHECK":
		return "CHECK"
	default:
		return pgConstraintType
	}
}

func (e *PostgreSQLExtractor) ParseIndexUnique(indexDef string) bool {
	return strings.Contains(strings.ToUpper(indexDef), "UNIQUE INDEX")
}

func (e *PostgreSQLExtractor) ParseIndexType(indexDef string) string {
	// Extract index type from CREATE INDEX statement
	re := regexp.MustCompile(`USING\s+(\w+)`)
	matches := re.FindStringSubmatch(indexDef)
	if len(matches) > 1 {
		return strings.ToLower(matches[1])
	}
	return "btree" // Default PostgreSQL index type
}

func (e *PostgreSQLExtractor) ParseIndexColumns(indexDef string) []string {
	// Extract column names from CREATE INDEX statement
	re := regexp.MustCompile(`\(([^)]+)\)`)
	matches := re.FindStringSubmatch(indexDef)
	if len(matches) > 1 {
		columnsPart := matches[1]
		// Split by comma and clean up
		var columns []string
		for _, col := range strings.Split(columnsPart, ",") {
			col = strings.TrimSpace(col)
			// Remove DESC/ASC and other modifiers
			parts := strings.Fields(col)
			if len(parts) > 0 {
				columns = append(columns, parts[0])
			}
		}
		return columns
	}
	return []string{}
}

func (e *PostgreSQLExtractor) ParseDefaultValue(pgDefault string) string {
	if pgDefault == "" || pgDefault == "NULL" {
		return ""
	}
	
	// Only remove PostgreSQL-specific casting for simple quoted values, not function calls
	re := regexp.MustCompile(`^'([^']*)'::[\w\s()]+$`)
	matches := re.FindStringSubmatch(pgDefault)
	if len(matches) > 1 {
		return matches[1]
	}
	
	return pgDefault
}

func (e *PostgreSQLExtractor) parsePostgreSQLVersion(versionString string) string {
	// Extract version number from PostgreSQL version string
	re := regexp.MustCompile(`PostgreSQL\s+(\d+\.\d+)`)
	matches := re.FindStringSubmatch(versionString)
	if len(matches) > 1 {
		return matches[1]
	}
	return versionString
}

func (e *PostgreSQLExtractor) HandleDatabaseError(err error) error {
	// Convert database-specific errors to our sentinel errors
	if err == nil {
		return nil
	}
	
	// For debugging, return the original error wrapped
	errStr := err.Error()
	switch {
	case strings.Contains(errStr, "connection"):
		return fmt.Errorf("connection error: %w", err)
	case strings.Contains(errStr, "does not exist"):
		return fmt.Errorf("schema not found: %w", err)
	case strings.Contains(errStr, "permission denied"):
		return fmt.Errorf("permission denied: %w", err)
	default:
		return fmt.Errorf("query execution failed: %w", err)
	}
}
