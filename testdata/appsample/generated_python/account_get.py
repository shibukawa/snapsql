# Generated by snapsql - DO NOT EDIT
# Generated at: 2025-11-10T14:58:18+09:00
# Function: AccountGet
# Dialect: sqlite

"""

"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Protocol
from datetime import datetime
from decimal import Decimal
import contextvars
import time
# SQLite async driver
try:
    import aiosqlite
except ImportError:
    raise ImportError("aiosqlite is required for SQLite. Install with: pip install aiosqlite")
_EXPLANG_EXPRESSIONS = [
    [
        ("identifier", "account_id", "", 0, False),
    ],
]

_EXPLANG_EPSILON = 1e-4

def _truthy(value: Any) -> bool:
    if value is None:
        return False
    if isinstance(value, bool):
        return value
    if isinstance(value, (int, float)):
        return abs(value) >= _EXPLANG_EPSILON
    if isinstance(value, str):
        return value != ""
    if isinstance(value, (list, tuple, dict, set)):
        return len(value) > 0
    return True


def _eval_explang_expression(expr_index: int, param_map: Dict[str, Any]) -> Any:
    if expr_index < 0 or expr_index >= len(_EXPLANG_EXPRESSIONS):
        raise ValueError(f"explang expression index {expr_index} out of range")
    steps = _EXPLANG_EXPRESSIONS[expr_index]
    current: Any = None
    for kind, identifier, prop, idx, safe in steps:
        if kind == "identifier":
            if identifier not in param_map:
                raise KeyError(f"parameter {identifier} not found for explang evaluation")
            current = param_map[identifier]
        elif kind == "member":
            current = _access_member(current, prop, safe)
        elif kind == "index":
            current = _access_index(current, idx, safe)
        else:
            raise ValueError(f"unsupported explang step kind: {kind}")
    return current


def _access_member(value: Any, prop: str, safe: bool) -> Any:
    if value is None:
        if safe:
            return None
        raise ValueError(f"cannot access member {prop} on None")
    if isinstance(value, dict):
        if prop in value:
            return value[prop]
        if safe:
            return None
        raise KeyError(f"field {prop} missing in dict")
    if hasattr(value, prop):
        return getattr(value, prop)
    if safe:
        return None
    raise AttributeError(f"field {prop} missing on {value}")


def _access_index(value: Any, idx: int, safe: bool) -> Any:
    if value is None:
        if safe:
            return None
        raise ValueError("cannot index None value")
    if isinstance(value, (list, tuple)):
        if 0 <= idx < len(value):
            return value[idx]
        if safe:
            return None
        raise IndexError(f"index {idx} out of range")
    if safe:
        return None
    raise TypeError(f"value of type {type(value)} is not indexable")


def _as_iterable(value: Any) -> List[Any]:
    if value is None:
        return []
    if isinstance(value, (list, tuple)):
        return list(value)
    return [value]


# ============================================================================
# Context Management
# ============================================================================

@dataclass
class SnapSQLContext:
    """SnapSQL execution context for managing system values and settings"""
    # System column values (created_by, updated_by, etc.)
    system_values: Dict[str, Any] = None
    
    # Query logging
    enable_query_log: bool = False
    query_logger: Optional[Any] = None
    
    # Mock execution
    mock_mode: bool = False
    mock_data: Optional[Dict[str, Any]] = None
    
    # Row locking
    row_lock_mode: str = "none"  # none, share, update
    
    def __post_init__(self):
        if self.system_values is None:
            self.system_values = {}
    
    def get_system_value(self, name: str, default: Any = None) -> Any:
        """Get system column value"""
        return self.system_values.get(name, default)
    
    def set_system_value(self, name: str, value: Any) -> None:
        """Set system column value"""
        self.system_values[name] = value


# Single context variable for all SnapSQL settings
snapsql_ctx: contextvars.ContextVar[Optional[SnapSQLContext]] = \
    contextvars.ContextVar('snapsql', default=None)


def get_snapsql_context() -> SnapSQLContext:
    """Get current SnapSQL context or create default"""
    ctx = snapsql_ctx.get()
    if ctx is None:
        ctx = SnapSQLContext()
        snapsql_ctx.set(ctx)
    return ctx


# ============================================================================
# Query Logging
# ============================================================================

@dataclass
class QueryLogMetadata:
    """Query metadata for logging"""
    func_name: str
    source_file: str
    dialect: str
    query_type: str  # "select", "insert", "update", "delete"


class QueryLogger(Protocol):
    """Query logger protocol for logging database operations"""
    
    def set_query(self, sql: str, args: List[Any]) -> None:
        """Set query and arguments before execution"""
        ...
    
    async def write(
        self,
        metadata: QueryLogMetadata,
        duration_ms: float,
        row_count: Optional[int],
        error: Optional[Exception]
    ) -> None:
        """Write query log after execution"""
        ...


class DefaultQueryLogger:
    """Default query logger implementation"""
    
    def __init__(self, slow_query_threshold_ms: float = 100.0):
        self.sql: Optional[str] = None
        self.args: Optional[List[Any]] = None
        self.logs: List[Dict[str, Any]] = []
        self.slow_query_threshold_ms = slow_query_threshold_ms
    
    def set_query(self, sql: str, args: List[Any]) -> None:
        """Set query and arguments before execution"""
        self.sql = sql
        self.args = args if args else []
    
    async def write(
        self,
        metadata: QueryLogMetadata,
        duration_ms: float,
        row_count: Optional[int],
        error: Optional[Exception]
    ) -> None:
        """Write query log after execution"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "func_name": metadata.func_name,
            "source_file": metadata.source_file,
            "dialect": metadata.dialect,
            "query_type": metadata.query_type,
            "sql": self.sql,
            "args": self.args,
            "duration_ms": duration_ms,
            "row_count": row_count,
            "error": str(error) if error else None,
            "is_slow": duration_ms > self.slow_query_threshold_ms
        }
        self.logs.append(log_entry)
        
        # Console output for errors and slow queries
        if error:
            print(f"[ERROR] {metadata.func_name}: {error} ({duration_ms:.2f}ms)")
        elif duration_ms > self.slow_query_threshold_ms:
            print(f"[SLOW] {metadata.func_name}: {duration_ms:.2f}ms")
    
    def get_logs(self) -> List[Dict[str, Any]]:
        """Get all logged entries"""
        return self.logs
    
    def get_slow_queries(self) -> List[Dict[str, Any]]:
        """Get slow query entries"""
        return [log for log in self.logs if log.get("is_slow", False)]
    
    def get_errors(self) -> List[Dict[str, Any]]:
        """Get error entries"""
        return [log for log in self.logs if log.get("error") is not None]
    
    def clear(self) -> None:
        """Clear all logs"""
        self.logs.clear()
        self.sql = None
        self.args = None


# ============================================================================
# Error Classes
# ============================================================================

class SnapSQLError(Exception):
    """Base exception for all SnapSQL errors"""
    
    def __init__(self, message: str, func_name: Optional[str] = None, 
                 query: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        self.message = message
        self.func_name = func_name
        self.query = query
        self.params = params
        super().__init__(self._format_message())
    
    def _format_message(self) -> str:
        """Format error message with context"""
        parts = [self.message]
        
        if self.func_name:
            parts.append(f"Function: {self.func_name}")
        
        if self.query:
            # Truncate long queries
            query_preview = self.query[:200] + "..." if len(self.query) > 200 else self.query
            parts.append(f"Query: {query_preview}")
        
        if self.params:
            # Format parameters for display
            param_str = ", ".join(f"{k}={repr(v)}" for k, v in self.params.items())
            if len(param_str) > 200:
                param_str = param_str[:200] + "..."
            parts.append(f"Parameters: {param_str}")
        
        return "\n".join(parts)


class NotFoundError(SnapSQLError):
    """Record not found (for 'one' affinity)"""
    
    def __init__(self, message: str = "Record not found", func_name: Optional[str] = None,
                 query: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        super().__init__(message, func_name, query, params)


class ValidationError(SnapSQLError):
    """Parameter validation failed"""
    
    def __init__(self, message: str, param_name: Optional[str] = None,
                 func_name: Optional[str] = None):
        self.param_name = param_name
        full_message = message
        if param_name:
            full_message = f"Parameter '{param_name}': {message}"
        super().__init__(full_message, func_name)


class DatabaseError(SnapSQLError):
    """Database operation failed"""
    
    def __init__(self, message: str, original_error: Optional[Exception] = None,
                 func_name: Optional[str] = None, query: Optional[str] = None,
                 params: Optional[Dict[str, Any]] = None):
        self.original_error = original_error
        error_msg = message
        if original_error:
            error_msg = f"{message}: {str(original_error)}"
        super().__init__(error_msg, func_name, query, params)


class UnsafeQueryError(SnapSQLError):
    """Unsafe query detected (e.g., UPDATE/DELETE without WHERE clause)"""
    
    def __init__(self, message: str, func_name: Optional[str] = None,
                 query: Optional[str] = None, mutation_kind: Optional[str] = None):
        self.mutation_kind = mutation_kind
        full_message = message
        if mutation_kind:
            full_message = f"{mutation_kind.upper()} operation: {message}"
        super().__init__(full_message, func_name, query)


# ============================================================================
# WHERE Clause Safety
# ============================================================================

def enforce_non_empty_where_clause(
    ctx: SnapSQLContext,
    func_name: str,
    mutation_kind: str,
    where_meta: Dict[str, Any],
    query: str
) -> None:
    """
    Enforce that UPDATE/DELETE statements have a WHERE clause.
    
    Args:
        ctx: SnapSQL context
        func_name: Name of the function executing the query
        mutation_kind: Type of mutation ('update' or 'delete')
        where_meta: WHERE clause metadata
        query: The SQL query string
        
    Raises:
        UnsafeQueryError: If WHERE clause is missing or empty
    """
    if mutation_kind not in ('update', 'delete'):
        return
    
    # Check if no-WHERE operations are allowed for this function
    # (This would be set via context configuration)
    if _is_no_where_allowed(ctx, func_name, mutation_kind):
        return
    
    status = where_meta.get('status', '').lower()
    
    # Check for fullscan status (no WHERE clause in template)
    if status == 'fullscan':
        raise UnsafeQueryError(
            f"{mutation_kind.upper()} {func_name} attempted without WHERE clause "
            f"(template omits WHERE clause). "
            f"Use context configuration to opt-in when intentional."
        )
    
    # Check for conditional status with fallback triggered
    if status == 'conditional' and where_meta.get('fallback_triggered', False):
        dynamic_conds = where_meta.get('dynamic_conditions', [])
        cond_desc = _describe_dynamic_conditions(dynamic_conds, filter_removable=True)
        hint = f"controlled by {cond_desc}" if cond_desc else "conditional filters evaluated to empty"
        raise UnsafeQueryError(
            f"{mutation_kind.upper()} {func_name} attempted without WHERE clause "
            f"({hint}). "
            f"Use context configuration to opt-in when intentional."
        )
    
    # Extract and validate WHERE clause from query
    has_where, clause = _extract_top_level_where_clause(query)
    if has_where and clause.strip():
        return
    
    # WHERE clause is missing or empty
    hint = "WHERE clause expected but missing in rendered SQL" if status == 'exists' else "WHERE clause state unknown"
    raise UnsafeQueryError(
        f"{mutation_kind.upper()} {func_name} attempted without WHERE clause "
        f"({hint}). "
        f"Use context configuration to opt-in when intentional."
    )


def _is_no_where_allowed(ctx: SnapSQLContext, func_name: str, mutation_kind: str) -> bool:
    """Check if no-WHERE operations are allowed for this function"""
    # This would check context configuration
    # For now, always return False (strict mode)
    return False


def _describe_dynamic_conditions(conditions: List[Dict[str, Any]], filter_removable: bool) -> str:
    """Generate description of dynamic conditions"""
    if not conditions:
        return ""
    
    labels = []
    for cond in conditions:
        if filter_removable and (not cond.get('negated_when_empty', False) or cond.get('has_else', False)):
            continue
        
        label = f"expr[{cond.get('expr_index', 0)}]"
        if cond.get('description'):
            label += f" {cond['description']}"
        labels.append(label)
    
    return ", ".join(labels)


def _extract_top_level_where_clause(query: str):
    """
    Extract the top-level WHERE clause from a SQL query.
    
    Returns:
        tuple: (has_where, clause_text) - Tuple of whether WHERE exists and its content
    """
    keyword_where = "WHERE"
    upper = query.upper()
    
    in_single = False
    in_double = False
    in_backtick = False
    in_line_comment = False
    in_block_comment = False
    depth = 0
    
    i = 0
    while i < len(upper):
        # Handle comments
        if in_line_comment:
            if upper[i] == '\n':
                in_line_comment = False
            i += 1
            continue
        
        if in_block_comment:
            if i + 1 < len(upper) and upper[i:i+2] == '*/':
                in_block_comment = False
                i += 2
                continue
            i += 1
            continue
        
        ch = upper[i]
        
        # Check for comment starts
        if not in_single and not in_double and not in_backtick:
            if i + 1 < len(upper) and upper[i:i+2] == '--':
                in_line_comment = True
                i += 2
                continue
            if i + 1 < len(upper) and upper[i:i+2] == '/*':
                in_block_comment = True
                i += 2
                continue
        
        # Handle string literals
        if not in_double and not in_backtick and ch == "'":
            in_single = not in_single
            i += 1
            continue
        if not in_single and not in_backtick and ch == '"':
            in_double = not in_double
            i += 1
            continue
        if not in_single and not in_double and ch == chr(96):  # backtick
            in_backtick = not in_backtick
            i += 1
            continue
        
        if in_single or in_double or in_backtick:
            i += 1
            continue
        
        # Track parenthesis depth
        if ch == '(':
            depth += 1
            i += 1
            continue
        if ch == ')':
            if depth > 0:
                depth -= 1
            i += 1
            continue
        
        # Look for WHERE keyword at depth 0
        if depth == 0 and upper[i:i+len(keyword_where)] == keyword_where:
            # Check word boundaries
            before = upper[i-1] if i > 0 else ' '
            after = upper[i+len(keyword_where)] if i+len(keyword_where) < len(upper) else ' '
            
            if not _is_identifier_char(before) and not _is_identifier_char(after):
                clause_start = i + len(keyword_where)
                clause_end = _find_clause_end(upper, clause_start)
                if clause_end < clause_start:
                    clause_end = len(query)
                
                return True, query[clause_start:clause_end]
        
        i += 1
    
    return False, ""


def _is_identifier_char(ch: str) -> bool:
    """Check if character is part of an identifier"""
    if not ch:
        return False
    return ch.isalnum() or ch == '_'


def _find_clause_end(upper: str, start: int) -> int:
    """Find the end of a WHERE clause"""
    keywords = ['RETURNING', 'ORDER', 'GROUP', 'LIMIT', 'FOR', 'USING']
    
    in_single = False
    in_double = False
    in_backtick = False
    in_line_comment = False
    in_block_comment = False
    depth = 0
    
    i = start
    while i < len(upper):
        # Handle comments
        if in_line_comment:
            if upper[i] == '\n':
                in_line_comment = False
            i += 1
            continue
        
        if in_block_comment:
            if i + 1 < len(upper) and upper[i:i+2] == '*/':
                in_block_comment = False
                i += 2
                continue
            i += 1
            continue
        
        ch = upper[i]
        
        # Check for comment starts
        if not in_single and not in_double and not in_backtick:
            if i + 1 < len(upper) and upper[i:i+2] == '--':
                in_line_comment = True
                i += 2
                continue
            if i + 1 < len(upper) and upper[i:i+2] == '/*':
                in_block_comment = True
                i += 2
                continue
        
        # Handle string literals
        if not in_double and not in_backtick and ch == "'":
            in_single = not in_single
            i += 1
            continue
        if not in_single and not in_backtick and ch == '"':
            in_double = not in_double
            i += 1
            continue
        if not in_single and not in_double and ch == chr(96):  # backtick
            in_backtick = not in_backtick
            i += 1
            continue
        
        if in_single or in_double or in_backtick:
            i += 1
            continue
        
        # Track parenthesis depth
        if ch == '(':
            depth += 1
            i += 1
            continue
        if ch == ')':
            if depth > 0:
                depth -= 1
            i += 1
            continue
        
        # Look for clause-ending keywords at depth 0
        if depth == 0:
            for kw in keywords:
                if upper[i:i+len(kw)] == kw:
                    before = upper[i-1] if i > 0 else ' '
                    if not _is_identifier_char(before):
                        return i
        
        i += 1
    
    return len(upper)

# ============================================================================
# Response Structures
# ============================================================================

@dataclass
class AccountGetResult:
    """Response structure for AccountGet"""
    id: Optional[int] = None
    name: Optional[str] = None
    status: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)


# ============================================================================
# Generated Functions
# ============================================================================
async def account_get(
    cursor: Any,
    account_id: int,
) -> AccountGetResult:
    """
    
    
    Args:
        account_id: 
    
    Returns:
        Result of AccountGet
    """
    # Validate required parameters
    if account_id is None:
        raise ValidationError(
            message="Required parameter 'account_id' cannot be None",
            param_name="account_id",
            func_name="AccountGet"
        )
    
    # Build SQL
    param_map = {
        "account_id": account_id,
    }
    sql = """SELECT id, name, status FROM accounts WHERE id = ? """
    args = [_eval_explang_expression(0, param_map)]
    
    # Execute query
    # Execute query and fetch single row
    await cursor.execute(sql, args)
    row = await cursor.fetchone()

    if row is None:
        # Build parameter dict for error message
        param_dict = {}
        # Note: args is a list, parameter names would need to be tracked separately
        raise NotFoundError(
            message="Record not found",
            func_name="AccountGet",
            query=sql,
            params=param_dict
        )

    # Map row to dataclass
    # aiosqlite with row_factory returns dict-like object
    return AccountGetResult(**row)
