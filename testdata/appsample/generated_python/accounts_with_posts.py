# Generated by snapsql - DO NOT EDIT
# Generated at: 2025-11-21T00:48:17+09:00
# Function: ListAccountsWithPosts
# Dialect: sqlite

"""

"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Union
from datetime import datetime
from decimal import Decimal
from .snapsql_runtime import (
    get_snapsql_context,
    NotFoundError,
    QueryLogMetadata,
)
# SQLite async driver
try:
    import aiosqlite
except ImportError:
    raise ImportError("aiosqlite is required for SQLite. Install with: pip install aiosqlite")

# ============================================================================
# Response Structures
# ============================================================================

@dataclass
class ListAccountsWithPostsResultPosts:
    """Response structure for ListAccountsWithPosts"""
    title: str
    id: Optional[int] = None
    body: Optional[str] = None
    published_at: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)

@dataclass
class ListAccountsWithPostsResult:
    """Response structure for ListAccountsWithPosts"""
    id: Optional[int] = None
    name: Optional[str] = None
    status: Optional[str] = None
    posts: List[ListAccountsWithPostsResultPosts] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)


# ============================================================================
# Generated Functions
# ============================================================================
async def list_accounts_with_posts(
    cursor: Union[aiosqlite.cursor.Cursor, aiosqlite.Connection],
) -> AsyncGenerator[ListAccountsWithPostsResult, None]:
    """
    
    
    Args:
    
    Returns:
        Result of ListAccountsWithPosts
    """
    
    # Build SQL
    sql = """SELECT a.id, a.name, a.status, p.id AS posts__id, p.title AS posts__title, p.body AS posts__body, p.published_at AS posts__published_at FROM accounts a LEFT JOIN posts p ON p.account_id = a.id ORDER BY a.id, p.id """
    args = []

    ctx = get_snapsql_context()
    logger = ctx.query_logger if ctx.enable_query_log else None
    error = None
    row_count = None
    import time
    start_time = time.time()
    try:
        # Execute query for hierarchical aggregation
        # This aggregates child records into parent objects

        if isinstance(cursor, aiosqlite.Connection):
            cursor = await cursor.execute(sql, args)
        else:
            await cursor.execute(sql, args)

        # Process rows for hierarchical aggregation
        current_parent = None
        current_parent_key = None

        async for row in cursor:
            row_dict = row if isinstance(row, dict) else dict(row)
            
            # Extract parent key
            parent_key = row_dict.get('id')
            
            # Check if we have a new parent
            if parent_key != current_parent_key:
                # Yield previous parent if exists
                if current_parent is not None:
                    yield current_parent
                
                # Create new parent object
                current_parent = ListAccountsWithPostsResult(
                    id=row_dict.get('id'),
                    name=row_dict.get('name'),
                    status=row_dict.get('status'),
                    posts=[]
                )
                current_parent_key = parent_key
            
            # Add child objects if present
            if any([row_dict.get('posts__id'), row_dict.get('posts__title'), row_dict.get('posts__body'), row_dict.get('posts__published_at')]):
                child_obj = ListAccountsWithPostsResultPosts(
                    id=row_dict.get('posts__id'),
                    title=row_dict.get('posts__title'),
                    body=row_dict.get('posts__body'),
                    published_at=row_dict.get('posts__published_at')
                )
                current_parent.posts.append(child_obj)

        # Yield last parent if exists
        if current_parent is not None:
            yield current_parent
    except Exception as err:
        error = err
        raise
    finally:
        if logger:
            duration_ms = (time.time() - start_time) * 1000
            metadata = QueryLogMetadata(
                func_name="ListAccountsWithPosts",
                source_file="ListAccountsWithPosts",
                dialect="sqlite",
                query_type="select"
            )
            await logger.write(metadata, duration_ms, row_count, error)
