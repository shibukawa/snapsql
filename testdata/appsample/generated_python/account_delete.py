# Generated by snapsql - DO NOT EDIT
# Generated at: 2025-11-21T00:48:17+09:00
# Function: AccountDelete
# Dialect: sqlite

"""

"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Union
from datetime import datetime
from decimal import Decimal
from .snapsql_runtime import (
    get_snapsql_context,
    ValidationError,
    NotFoundError,
    UnsafeQueryError,
    QueryLogMetadata,
)
# SQLite async driver
try:
    import aiosqlite
except ImportError:
    raise ImportError("aiosqlite is required for SQLite. Install with: pip install aiosqlite")

# ============================================================================
# Response Structures
# ============================================================================

@dataclass
class AccountDeleteResult:
    """Response structure for AccountDelete"""
    affected_rows: int
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)


# ============================================================================
# Generated Functions
# ============================================================================
async def account_delete(
    cursor: Union[aiosqlite.cursor.Cursor, aiosqlite.Connection],
    account_id: int,
    account_name: str,
    include_identifier_filter: bool,
    prefer_name_filter: bool,
) -> AccountDeleteResult:
    """
    
    
    Args:
        account_id: 
        account_name: 
        include_identifier_filter: 
        prefer_name_filter: 
    
    Returns:
        Result of AccountDelete
    """
    # Validate required parameters
    if account_id is None:
        raise ValidationError(
            message="Required parameter 'account_id' cannot be None",
            param_name="account_id",
            func_name="AccountDelete"
        )
    if account_name is None:
        raise ValidationError(
            message="Required parameter 'account_name' cannot be None",
            param_name="account_name",
            func_name="AccountDelete"
        )
    if include_identifier_filter is None:
        raise ValidationError(
            message="Required parameter 'include_identifier_filter' cannot be None",
            param_name="include_identifier_filter",
            func_name="AccountDelete"
        )
    if prefer_name_filter is None:
        raise ValidationError(
            message="Required parameter 'prefer_name_filter' cannot be None",
            param_name="prefer_name_filter",
            func_name="AccountDelete"
        )
    
    # Build SQL
    # Dynamic SQL building
    # Build SQL dynamically
    sql_parts = []
    args = []
    sql_parts.append("DELETE FROM accounts WHERE ")
    cond_value = include_identifier_filter
    if cond_value:
        sql_parts.append(" ")
        cond_value = prefer_name_filter
        if cond_value:
            sql_parts.append(" name = ?")
            args.append(account_name)
            sql_parts.append(" ")
        else:
            sql_parts.append(" id = ?")
            args.append(account_id)
            sql_parts.append(" ")
        sql_parts.append(" ")
    sql_parts.append(" ")

    # Join SQL parts
    sql = ''.join(sql_parts)
    ctx = get_snapsql_context()
    if not ctx.allow_unsafe_mutations:
        # WHERE clause guard for delete
        if not (include_identifier_filter):
            raise UnsafeQueryError(
                message="DELETE AccountDelete attempted without WHERE clause (include_identifier_filter)",
                func_name="AccountDelete",
                query=sql,
                mutation_kind="delete"
            )


    ctx = get_snapsql_context()
    logger = ctx.query_logger if ctx.enable_query_log else None
    error = None
    row_count = None
    import time
    start_time = time.time()
    try:
        # Execute query (no result expected)
        if isinstance(cursor, aiosqlite.Connection):
            cursor = await cursor.execute(sql, args)
        else:
            await cursor.execute(sql, args)
        return cursor.rowcount
    except Exception as err:
        error = err
        raise
    finally:
        if logger:
            duration_ms = (time.time() - start_time) * 1000
            metadata = QueryLogMetadata(
                func_name="AccountDelete",
                source_file="AccountDelete",
                dialect="sqlite",
                query_type="delete"
            )
            await logger.write(metadata, duration_ms, row_count, error)
