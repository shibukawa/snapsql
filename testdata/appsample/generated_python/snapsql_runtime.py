# Generated by snapsql - DO NOT EDIT
# Shared runtime helpers
# Generated at: 2025-11-21T00:48:17+09:00

from dataclasses import dataclass
from typing import Optional, List, Any, Dict, Protocol
from datetime import datetime
import contextvars


# ============================================================================
# Context Management
# ============================================================================

@dataclass
class SnapSQLContext:
    """SnapSQL execution context for managing system values and settings"""
    # System column values (created_by, updated_by, etc.)
    system_values: Dict[str, Any] = None
    
    # Query logging
    enable_query_log: bool = False
    query_logger: Optional[Any] = None
    
    # Mock execution
    mock_mode: bool = False
    mock_data: Optional[Dict[str, Any]] = None
    
    # Row locking
    row_lock_mode: str = "none"  # none, share, update
    
    # Unsafe mutation allowance
    allow_unsafe_mutations: bool = False
    
    def __post_init__(self):
        if self.system_values is None:
            self.system_values = {}
    
    def get_system_value(self, name: str, default: Any = None) -> Any:
        """Get system column value"""
        return self.system_values.get(name, default)
    
    def set_system_value(self, name: str, value: Any) -> None:
        """Set system column value"""
        self.system_values[name] = value

    def allow_mutations(self, allow: bool) -> None:
        """Allow or disallow unsafe mutations"""
        self.allow_unsafe_mutations = allow

    def set_row_lock_mode(self, mode: str) -> None:
        """Set desired row lock mode"""
        self.row_lock_mode = mode

    def set_query_logger(self, logger) -> None:
        """Attach a query logger for this context"""
        self.query_logger = logger

    def enable_query_log(self, enabled: bool = True) -> None:
        """Enable or disable query logging"""
        self.enable_query_log = enabled


# Single context variable for all SnapSQL settings
ROW_LOCK_NONE = "none"
ROW_LOCK_FOR_UPDATE = "for_update"
ROW_LOCK_FOR_SHARE = "for_share"
ROW_LOCK_FOR_UPDATE_NOWAIT = "for_update_nowait"
ROW_LOCK_FOR_UPDATE_SKIP_LOCKED = "for_update_skip_locked"

snapsql_ctx: contextvars.ContextVar[Optional[SnapSQLContext]] = \
    contextvars.ContextVar('snapsql', default=None)


def get_snapsql_context() -> SnapSQLContext:
    """Get current SnapSQL context or create default"""
    ctx = snapsql_ctx.get()
    if ctx is None:
        ctx = SnapSQLContext()
        snapsql_ctx.set(ctx)
    return ctx


def set_system_value(name: str, value: Any) -> None:
    """Set system column value in the current context"""
    ctx = get_snapsql_context()
    ctx.set_system_value(name, value)


def update_system_values(values: Dict[str, Any]) -> None:
    """Update multiple system column values"""
    ctx = get_snapsql_context()
    ctx.system_values.update(values)


def set_row_lock_mode(mode: str) -> None:
    """Switch the desired row lock mode"""
    ctx = get_snapsql_context()
    ctx.set_row_lock_mode(mode)


def set_mock_mode(enabled: bool, mock_data: Optional[Dict[str, Any]] = None) -> None:
    """Enable or disable mock execution"""
    ctx = get_snapsql_context()
    ctx.mock_mode = enabled
    if mock_data is not None:
        ctx.mock_data = mock_data


def set_query_logger(logger) -> None:
    """Set the query logger for future executions"""
    ctx = get_snapsql_context()
    ctx.query_logger = logger


def enable_query_logging(enabled: bool = True) -> None:
    """Enable or disable query logging globally"""
    ctx = get_snapsql_context()
    ctx.enable_query_log = enabled


def allow_unsafe_queries(allow: bool = True) -> None:
    """Override the unsafe query guard for the current context"""
    ctx = get_snapsql_context()
    ctx.allow_unsafe_mutations = allow


# ============================================================================
# Query Logging
# ============================================================================

@dataclass
class QueryLogMetadata:
    """Query metadata for logging"""
    func_name: str
    source_file: str
    dialect: str
    query_type: str  # "select", "insert", "update", "delete"


class QueryLogger(Protocol):
    """Query logger protocol for logging database operations"""
    
    def set_query(self, sql: str, args: List[Any]) -> None:
        """Set query and arguments before execution"""
        ...
    
    async def write(
        self,
        metadata: QueryLogMetadata,
        duration_ms: float,
        row_count: Optional[int],
        error: Optional[Exception]
    ) -> None:
        """Write query log after execution"""
        ...


class DefaultQueryLogger:
    """Default query logger implementation"""
    
    def __init__(self, slow_query_threshold_ms: float = 100.0):
        self.sql: Optional[str] = None
        self.args: Optional[List[Any]] = None
        self.logs: List[Dict[str, Any]] = []
        self.slow_query_threshold_ms = slow_query_threshold_ms
    
    def set_query(self, sql: str, args: List[Any]) -> None:
        """Set query and arguments before execution"""
        self.sql = sql
        self.args = args if args else []
    
    async def write(
        self,
        metadata: QueryLogMetadata,
        duration_ms: float,
        row_count: Optional[int],
        error: Optional[Exception]
    ) -> None:
        """Write query log after execution"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "func_name": metadata.func_name,
            "source_file": metadata.source_file,
            "dialect": metadata.dialect,
            "query_type": metadata.query_type,
            "sql": self.sql,
            "args": self.args,
            "duration_ms": duration_ms,
            "row_count": row_count,
            "error": str(error) if error else None,
            "is_slow": duration_ms > self.slow_query_threshold_ms
        }
        self.logs.append(log_entry)
        
        # Console output for errors and slow queries
        if error:
            print(f"[ERROR] {metadata.func_name}: {error} ({duration_ms:.2f}ms)")
        elif duration_ms > self.slow_query_threshold_ms:
            print(f"[SLOW] {metadata.func_name}: {duration_ms:.2f}ms")
    
    def get_logs(self) -> List[Dict[str, Any]]:
        """Get all logged entries"""
        return self.logs
    
    def get_slow_queries(self) -> List[Dict[str, Any]]:
        """Get slow query entries"""
        return [log for log in self.logs if log.get("is_slow", False)]
    
    def get_errors(self) -> List[Dict[str, Any]]:
        """Get error entries"""
        return [log for log in self.logs if log.get("error") is not None]
    
    def clear(self) -> None:
        """Clear all logs"""
        self.logs.clear()
        self.sql = None
        self.args = None


# ============================================================================
# Error Classes
# ============================================================================

class SnapSQLError(Exception):
    """Base exception for all SnapSQL errors"""
    
    def __init__(self, message: str, func_name: Optional[str] = None, 
                 query: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        self.message = message
        self.func_name = func_name
        self.query = query
        self.params = params
        super().__init__(self._format_message())
    
    def _format_message(self) -> str:
        """Format error message with context"""
        parts = [self.message]
        
        if self.func_name:
            parts.append(f"Function: {self.func_name}")
        
        if self.query:
            # Truncate long queries
            query_preview = self.query[:200] + "..." if len(self.query) > 200 else self.query
            parts.append(f"Query: {query_preview}")
        
        if self.params:
            # Format parameters for display
            param_str = ", ".join(f"{k}={repr(v)}" for k, v in self.params.items())
            if len(param_str) > 200:
                param_str = param_str[:200] + "..."
            parts.append(f"Parameters: {param_str}")
        
        return "\n".join(parts)


class NotFoundError(SnapSQLError):
    """Record not found (for 'one' affinity)"""
    
    def __init__(self, message: str = "Record not found", func_name: Optional[str] = None,
                 query: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        super().__init__(message, func_name, query, params)


class ValidationError(SnapSQLError):
    """Parameter validation failed"""
    
    def __init__(self, message: str, param_name: Optional[str] = None,
                 func_name: Optional[str] = None):
        self.param_name = param_name
        full_message = message
        if param_name:
            full_message = f"Parameter '{param_name}': {message}"
        super().__init__(full_message, func_name)


class DatabaseError(SnapSQLError):
    """Database operation failed"""
    
    def __init__(self, message: str, original_error: Optional[Exception] = None,
                 func_name: Optional[str] = None, query: Optional[str] = None,
                 params: Optional[Dict[str, Any]] = None):
        self.original_error = original_error
        error_msg = message
        if original_error:
            error_msg = f"{message}: {str(original_error)}"
        super().__init__(error_msg, func_name, query, params)


class UnsafeQueryError(SnapSQLError):
    """Unsafe query detected (e.g., UPDATE/DELETE without WHERE clause)"""
    
    def __init__(self, message: str, func_name: Optional[str] = None,
                 query: Optional[str] = None, mutation_kind: Optional[str] = None):
        self.mutation_kind = mutation_kind
        full_message = message
        if mutation_kind:
            full_message = f"{mutation_kind.upper()} operation: {message}"
        super().__init__(full_message, func_name, query)


class RowLockError(SnapSQLError):
    """Row lock configuration failed or is unsupported"""

    def __init__(self, message: str, func_name: Optional[str] = None):
        super().__init__(message, func_name)


def ensure_row_lock_allowed(query_type: str, mode: Optional[str]) -> None:
    """Ensure the configured row lock is allowed for the given query type"""
    if not mode:
        return

    if mode == ROW_LOCK_NONE:
        return

    if query_type.lower() != "select":
        raise RowLockError(f"Row lock enabled for non-SELECT query ({query_type})")


def build_row_lock_clause_postgres(mode: str) -> str:
    """Return the Postgres row lock clause for the requested mode"""
    if mode == ROW_LOCK_FOR_UPDATE:
        return " FOR UPDATE"
    if mode == ROW_LOCK_FOR_SHARE:
        return " FOR SHARE"
    if mode == ROW_LOCK_FOR_UPDATE_NOWAIT:
        return " FOR UPDATE NOWAIT"
    if mode == ROW_LOCK_FOR_UPDATE_SKIP_LOCKED:
        return " FOR UPDATE SKIP LOCKED"

    raise RowLockError(f"Unsupported row lock mode: {mode}")


def build_row_lock_clause_mysql(mode: str) -> str:
    """Return the MySQL row lock clause for the requested mode"""
    return build_row_lock_clause_postgres(mode)


def build_row_lock_clause_mariadb(mode: str) -> str:
    """Return the MariaDB row lock clause for the requested mode"""
    return build_row_lock_clause_postgres(mode)


def build_row_lock_clause_sqlite(mode: str) -> str:
    """SQLite does not support row locks, so this always returns an empty clause"""
    return ""

