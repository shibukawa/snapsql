package pygen

import "github.com/shibukawa/snapsql"

// pythonTemplate is the Go text/template for generating Python code
// It follows the same pattern as gogen but outputs Python instead of Go
const pythonTemplate = `# Generated by snapsql - DO NOT EDIT
# Generated at: {{ .Timestamp }}
# Function: {{ .FunctionName }}
# Dialect: {{ .Dialect }}

"""
{{ .Description }}
"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Union
from datetime import datetime
from decimal import Decimal

{{- if .RuntimeImports }}
from .snapsql_runtime import (
{{- range $i, $import := .RuntimeImports }}
    {{ $import }},
{{- end }}
)
{{- end }}

{{- if eq .Dialect "postgres" }}
# PostgreSQL async driver
try:
    import asyncpg
except ImportError:
    raise ImportError("asyncpg is required for PostgreSQL. Install with: pip install asyncpg")
{{- else if eq .Dialect "mysql" }}
# MySQL async driver
try:
    import aiomysql
except ImportError:
    raise ImportError("aiomysql is required for MySQL. Install with: pip install aiomysql")
{{- else if eq .Dialect "sqlite" }}
# SQLite async driver
try:
    import aiosqlite
except ImportError:
    raise ImportError("aiosqlite is required for SQLite. Install with: pip install aiosqlite")
{{- end }}


{{- if .HasMock }}
{{ .MockData.MockLoadCode }}
{{- end }}

# ============================================================================
# Response Structures
# ============================================================================
{{- range .ResponseStructs }}

@dataclass
class {{ .ClassName }}:
    """Response structure for {{ $.FunctionName }}"""
{{- range .Fields }}
    {{ .Name }}: {{ .TypeHint }}{{ if .HasDefault }} = {{ .Default }}{{ end }}
{{- end }}
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)
{{- end }}


# ============================================================================
# Generated Functions
# ============================================================================

{{- if eq .ResponseAffinity "many" }}
async def {{ .FunctionName | snakeCase }}(
{{- if eq .Dialect "postgres" }}
    conn: asyncpg.Connection,
{{- else if eq .Dialect "sqlite" }}
    cursor: Union[aiosqlite.cursor.Cursor, aiosqlite.Connection],
{{- else }}
    cursor: Any,
{{- end }}
{{- range .Parameters }}
    {{ .Name }}: {{ .TypeHint }}{{ if .HasDefault }} = {{ .Default }}{{ end }},
{{- end }}
{{- if .HasImplicitParams }}
    *,
{{- range .ImplicitParams }}
    {{ .Name }}: Optional[{{ .TypeHint }}] = None,
{{- end }}
{{- end }}
) -> AsyncGenerator[{{ .ReturnType }}, None]:
{{- else }}
async def {{ .FunctionName | snakeCase }}(
{{- if eq .Dialect "postgres" }}
    conn: asyncpg.Connection,
{{- else if eq .Dialect "sqlite" }}
    cursor: Union[aiosqlite.cursor.Cursor, aiosqlite.Connection],
{{- else }}
    cursor: Any,
{{- end }}
{{- range .Parameters }}
    {{ .Name }}: {{ .TypeHint }}{{ if .HasDefault }} = {{ .Default }}{{ end }},
{{- end }}
{{- if .HasImplicitParams }}
    *,
{{- range .ImplicitParams }}
    {{ .Name }}: Optional[{{ .TypeHint }}] = None,
{{- end }}
{{- end }}
) -> {{ .ReturnType }}:
{{- end }}
    """
    {{ .Description }}
    
    Args:
{{- range .Parameters }}
        {{ .Name }}: {{ .Description }}
{{- end }}
{{- range .ImplicitParams }}
        {{ .Name }}: {{ .Description }} (optional, uses context if not provided)
{{- end }}
    
    Returns:
        {{ .ReturnTypeDescription }}
    """
{{- if .HasImplicitParams }}
    # Get context for implicit parameters
    ctx = get_snapsql_context()
    
{{- range .ImplicitParams }}
    if {{ .Name }} is None:
        {{ .Name }} = ctx.get_system_value('{{ .Name }}')
{{- if .HasDefaultValue }}
        if {{ .Name }} is None:
            {{ .Name }} = {{ .DefaultValue }}
{{- end }}
{{- end }}
{{- end }}
    
{{- if .HasValidation }}
    # Validate required parameters
{{- range .Validations }}
    if {{ .Condition }}:
        raise ValidationError(
            message={{ .Message | printf "%q" }},
            param_name={{ .ParamName | printf "%q" }},
            func_name={{ $.FunctionName | printf "%q" }}
        )
{{- end }}
{{- end }}
    
    # Build SQL
{{- if .SQLBuilder.IsStatic }}
    sql = """{{ .SQLBuilder.StaticSQL }}"""
    args = [{{ range $i, $arg := .SQLBuilder.Args }}{{ if $i }}, {{ end }}{{ $arg }}{{ end }}]
{{- else }}
    # Dynamic SQL building
{{ .SQLBuilder.DynamicCode | indent 4 }}
{{- end }}
    
{{- if .HasMock }}
{{ .MockData.MockExecCode | indent 4 }}
{{- end }}
    
{{- if .WhereGuardCode }}
{{ .WhereGuardCode | indent 4 }}
{{- end }}

    ctx = get_snapsql_context()
{{- if .NeedsRowLockClause }}
    row_lock_clause = ""
    if ctx.row_lock_mode not in (None, "", ROW_LOCK_NONE):
        ensure_row_lock_allowed({{ .QueryType | printf "%q" }}, ctx.row_lock_mode)
        row_lock_clause = {{ .RowLockBuilderCall }}
        if row_lock_clause:
            sql += row_lock_clause
{{- end }}

{{- if .EnableQueryLogging }}
    logger = ctx.query_logger if ctx.enable_query_log else None
    error = None
    row_count = None
    import time
    start_time = time.time()
    try:
{{ .QueryExecution.Code | indent 8 }}
    except Exception as err:
        error = err
        raise
    finally:
        if logger:
            duration_ms = (time.time() - start_time) * 1000
            metadata = QueryLogMetadata(
                func_name={{ .FunctionName | printf "%q" }},
                source_file={{ .FunctionName | printf "%q" }},
                dialect={{ .Dialect | printf "%q" }},
                query_type={{ .QueryType | printf "%q" }}
            )
            await logger.write(metadata, duration_ms, row_count, error)
{{- else }}
    # Execute query
{{ .QueryExecution.Code | indent 4 }}
{{- end }}
`

// templateData represents the data passed to the Python template
type templateData struct {
	// Metadata
	Timestamp    string
	FunctionName string
	Description  string
	Dialect      snapsql.Dialect

	// Features
	HasImplicitParams bool
	HasValidation     bool
	HasMock           bool

	// Response structures
	ResponseStructs []responseStructData

	// Parameters
	Parameters     []parameterData
	ImplicitParams []implicitParamData
	Validations    []validationData

	// SQL Building
	SQLBuilder sqlBuilderData

	// Query Execution
	QueryExecution queryExecutionData

	// Mock
	MockData mockTemplateData

	// Return type
	ReturnType            string
	ReturnTypeDescription string
	ResponseAffinity      string

	// Runtime imports
	RuntimeImports []string

	// Logging
	QueryType          string
	EnableQueryLogging bool

	// Row lock
	NeedsRowLockClause bool
	RowLockBuilderCall string

	// WHERE clause safety
	MutationKind   string
	WhereGuardCode string
}

// responseStructData represents a Python dataclass for responses
type responseStructData struct {
	ClassName string
	Fields    []responseFieldData
}

// responseFieldData represents a field in a response dataclass
type responseFieldData struct {
	Name       string
	TypeHint   string
	HasDefault bool
	Default    string
}

// parameterData represents a function parameter
type parameterData struct {
	Name        string
	TypeHint    string
	Description string
	HasDefault  bool
	Default     string
}

// implicitParamData represents an implicit parameter (from context)
type implicitParamData struct {
	Name            string
	TypeHint        string
	Description     string
	HasDefaultValue bool
	DefaultValue    string
}

// validationData represents a parameter validation
type validationData struct {
	Condition string
	Message   string
	ParamName string // Parameter name for better error messages
}

// sqlBuilderData represents SQL building code
type sqlBuilderData struct {
	IsStatic    bool
	StaticSQL   string
	Args        []string
	DynamicCode string
}

// queryExecutionData represents query execution code
type queryExecutionData struct {
	Code              string
	UsesNotFoundError bool
}
