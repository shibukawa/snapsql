package pygen

// pythonTemplate is the Go text/template for generating Python code
// It follows the same pattern as gogen but outputs Python instead of Go
const pythonTemplate = `# Generated by snapsql - DO NOT EDIT
# Generated at: {{ .Timestamp }}
# Function: {{ .FunctionName }}
# Dialect: {{ .Dialect }}

"""
{{ .Description }}
"""

from dataclasses import dataclass, asdict
from typing import Optional, List, Any, Dict, AsyncGenerator, Protocol
from datetime import datetime
from decimal import Decimal
import contextvars
import time

{{- if eq .Dialect "postgres" }}
# PostgreSQL async driver
try:
    import asyncpg
except ImportError:
    raise ImportError("asyncpg is required for PostgreSQL. Install with: pip install asyncpg")
{{- else if eq .Dialect "mysql" }}
# MySQL async driver
try:
    import aiomysql
except ImportError:
    raise ImportError("aiomysql is required for MySQL. Install with: pip install aiomysql")
{{- else if eq .Dialect "sqlite" }}
# SQLite async driver
try:
    import aiosqlite
except ImportError:
    raise ImportError("aiosqlite is required for SQLite. Install with: pip install aiosqlite")
{{- end }}

{{- if .HasCEL }}
# CEL library for dynamic expressions (synchronous, used within async functions)
try:
    import celpy
except ImportError:
    celpy = None  # CEL is optional, will raise error if CEL expressions are used
{{- end }}


# ============================================================================
# Context Management
# ============================================================================

@dataclass
class SnapSQLContext:
    """SnapSQL execution context for managing system values and settings"""
    # System column values (created_by, updated_by, etc.)
    system_values: Dict[str, Any] = None
    
    # Query logging
    enable_query_log: bool = False
    query_logger: Optional[Any] = None
    
    # Mock execution
    mock_mode: bool = False
    mock_data: Optional[Dict[str, Any]] = None
    
    # Row locking
    row_lock_mode: str = "none"  # none, share, update
    
    def __post_init__(self):
        if self.system_values is None:
            self.system_values = {}
    
    def get_system_value(self, name: str, default: Any = None) -> Any:
        """Get system column value"""
        return self.system_values.get(name, default)
    
    def set_system_value(self, name: str, value: Any) -> None:
        """Set system column value"""
        self.system_values[name] = value


# Single context variable for all SnapSQL settings
snapsql_ctx: contextvars.ContextVar[Optional[SnapSQLContext]] = \
    contextvars.ContextVar('snapsql', default=None)


def get_snapsql_context() -> SnapSQLContext:
    """Get current SnapSQL context or create default"""
    ctx = snapsql_ctx.get()
    if ctx is None:
        ctx = SnapSQLContext()
        snapsql_ctx.set(ctx)
    return ctx


# ============================================================================
# Query Logging
# ============================================================================

@dataclass
class QueryLogMetadata:
    """Query metadata for logging"""
    func_name: str
    source_file: str
    dialect: str
    query_type: str  # "select", "insert", "update", "delete"


class QueryLogger(Protocol):
    """Query logger protocol for logging database operations"""
    
    def set_query(self, sql: str, args: List[Any]) -> None:
        """Set query and arguments before execution"""
        ...
    
    async def write(
        self,
        metadata: QueryLogMetadata,
        duration_ms: float,
        row_count: Optional[int],
        error: Optional[Exception]
    ) -> None:
        """Write query log after execution"""
        ...


class DefaultQueryLogger:
    """Default query logger implementation"""
    
    def __init__(self, slow_query_threshold_ms: float = 100.0):
        self.sql: Optional[str] = None
        self.args: Optional[List[Any]] = None
        self.logs: List[Dict[str, Any]] = []
        self.slow_query_threshold_ms = slow_query_threshold_ms
    
    def set_query(self, sql: str, args: List[Any]) -> None:
        """Set query and arguments before execution"""
        self.sql = sql
        self.args = args if args else []
    
    async def write(
        self,
        metadata: QueryLogMetadata,
        duration_ms: float,
        row_count: Optional[int],
        error: Optional[Exception]
    ) -> None:
        """Write query log after execution"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "func_name": metadata.func_name,
            "source_file": metadata.source_file,
            "dialect": metadata.dialect,
            "query_type": metadata.query_type,
            "sql": self.sql,
            "args": self.args,
            "duration_ms": duration_ms,
            "row_count": row_count,
            "error": str(error) if error else None,
            "is_slow": duration_ms > self.slow_query_threshold_ms
        }
        self.logs.append(log_entry)
        
        # Console output for errors and slow queries
        if error:
            print(f"[ERROR] {metadata.func_name}: {error} ({duration_ms:.2f}ms)")
        elif duration_ms > self.slow_query_threshold_ms:
            print(f"[SLOW] {metadata.func_name}: {duration_ms:.2f}ms")
    
    def get_logs(self) -> List[Dict[str, Any]]:
        """Get all logged entries"""
        return self.logs
    
    def get_slow_queries(self) -> List[Dict[str, Any]]:
        """Get slow query entries"""
        return [log for log in self.logs if log.get("is_slow", False)]
    
    def get_errors(self) -> List[Dict[str, Any]]:
        """Get error entries"""
        return [log for log in self.logs if log.get("error") is not None]
    
    def clear(self) -> None:
        """Clear all logs"""
        self.logs.clear()
        self.sql = None
        self.args = None


# ============================================================================
# Error Classes
# ============================================================================

class SnapSQLError(Exception):
    """Base exception for all SnapSQL errors"""
    
    def __init__(self, message: str, func_name: Optional[str] = None, 
                 query: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        self.message = message
        self.func_name = func_name
        self.query = query
        self.params = params
        super().__init__(self._format_message())
    
    def _format_message(self) -> str:
        """Format error message with context"""
        parts = [self.message]
        
        if self.func_name:
            parts.append(f"Function: {self.func_name}")
        
        if self.query:
            # Truncate long queries
            query_preview = self.query[:200] + "..." if len(self.query) > 200 else self.query
            parts.append(f"Query: {query_preview}")
        
        if self.params:
            # Format parameters for display
            param_str = ", ".join(f"{k}={repr(v)}" for k, v in self.params.items())
            if len(param_str) > 200:
                param_str = param_str[:200] + "..."
            parts.append(f"Parameters: {param_str}")
        
        return "\n".join(parts)


class NotFoundError(SnapSQLError):
    """Record not found (for 'one' affinity)"""
    
    def __init__(self, message: str = "Record not found", func_name: Optional[str] = None,
                 query: Optional[str] = None, params: Optional[Dict[str, Any]] = None):
        super().__init__(message, func_name, query, params)


class ValidationError(SnapSQLError):
    """Parameter validation failed"""
    
    def __init__(self, message: str, param_name: Optional[str] = None,
                 func_name: Optional[str] = None):
        self.param_name = param_name
        full_message = message
        if param_name:
            full_message = f"Parameter '{param_name}': {message}"
        super().__init__(full_message, func_name)


class DatabaseError(SnapSQLError):
    """Database operation failed"""
    
    def __init__(self, message: str, original_error: Optional[Exception] = None,
                 func_name: Optional[str] = None, query: Optional[str] = None,
                 params: Optional[Dict[str, Any]] = None):
        self.original_error = original_error
        error_msg = message
        if original_error:
            error_msg = f"{message}: {str(original_error)}"
        super().__init__(error_msg, func_name, query, params)


class UnsafeQueryError(SnapSQLError):
    """Unsafe query detected (e.g., UPDATE/DELETE without WHERE clause)"""
    
    def __init__(self, message: str, func_name: Optional[str] = None,
                 query: Optional[str] = None, mutation_kind: Optional[str] = None):
        self.mutation_kind = mutation_kind
        full_message = message
        if mutation_kind:
            full_message = f"{mutation_kind.upper()} operation: {message}"
        super().__init__(full_message, func_name, query)


# ============================================================================
# WHERE Clause Safety
# ============================================================================

def enforce_non_empty_where_clause(
    ctx: SnapSQLContext,
    func_name: str,
    mutation_kind: str,
    where_meta: Dict[str, Any],
    query: str
) -> None:
    """
    Enforce that UPDATE/DELETE statements have a WHERE clause.
    
    Args:
        ctx: SnapSQL context
        func_name: Name of the function executing the query
        mutation_kind: Type of mutation ('update' or 'delete')
        where_meta: WHERE clause metadata
        query: The SQL query string
        
    Raises:
        UnsafeQueryError: If WHERE clause is missing or empty
    """
    if mutation_kind not in ('update', 'delete'):
        return
    
    # Check if no-WHERE operations are allowed for this function
    # (This would be set via context configuration)
    if _is_no_where_allowed(ctx, func_name, mutation_kind):
        return
    
    status = where_meta.get('status', '').lower()
    
    # Check for fullscan status (no WHERE clause in template)
    if status == 'fullscan':
        raise UnsafeQueryError(
            f"{mutation_kind.upper()} {func_name} attempted without WHERE clause "
            f"(template omits WHERE clause). "
            f"Use context configuration to opt-in when intentional."
        )
    
    # Check for conditional status with fallback triggered
    if status == 'conditional' and where_meta.get('fallback_triggered', False):
        dynamic_conds = where_meta.get('dynamic_conditions', [])
        cond_desc = _describe_dynamic_conditions(dynamic_conds, filter_removable=True)
        hint = f"controlled by {cond_desc}" if cond_desc else "conditional filters evaluated to empty"
        raise UnsafeQueryError(
            f"{mutation_kind.upper()} {func_name} attempted without WHERE clause "
            f"({hint}). "
            f"Use context configuration to opt-in when intentional."
        )
    
    # Extract and validate WHERE clause from query
    has_where, clause = _extract_top_level_where_clause(query)
    if has_where and clause.strip():
        return
    
    # WHERE clause is missing or empty
    hint = "WHERE clause expected but missing in rendered SQL" if status == 'exists' else "WHERE clause state unknown"
    raise UnsafeQueryError(
        f"{mutation_kind.upper()} {func_name} attempted without WHERE clause "
        f"({hint}). "
        f"Use context configuration to opt-in when intentional."
    )


def _is_no_where_allowed(ctx: SnapSQLContext, func_name: str, mutation_kind: str) -> bool:
    """Check if no-WHERE operations are allowed for this function"""
    # This would check context configuration
    # For now, always return False (strict mode)
    return False


def _describe_dynamic_conditions(conditions: List[Dict[str, Any]], filter_removable: bool) -> str:
    """Generate description of dynamic conditions"""
    if not conditions:
        return ""
    
    labels = []
    for cond in conditions:
        if filter_removable and (not cond.get('negated_when_empty', False) or cond.get('has_else', False)):
            continue
        
        label = f"expr[{cond.get('expr_index', 0)}]"
        if cond.get('description'):
            label += f" {cond['description']}"
        labels.append(label)
    
    return ", ".join(labels)


def _extract_top_level_where_clause(query: str):
    """
    Extract the top-level WHERE clause from a SQL query.
    
    Returns:
        tuple: (has_where, clause_text) - Tuple of whether WHERE exists and its content
    """
    keyword_where = "WHERE"
    upper = query.upper()
    
    in_single = False
    in_double = False
    in_backtick = False
    in_line_comment = False
    in_block_comment = False
    depth = 0
    
    i = 0
    while i < len(upper):
        # Handle comments
        if in_line_comment:
            if upper[i] == '\n':
                in_line_comment = False
            i += 1
            continue
        
        if in_block_comment:
            if i + 1 < len(upper) and upper[i:i+2] == '*/':
                in_block_comment = False
                i += 2
                continue
            i += 1
            continue
        
        ch = upper[i]
        
        # Check for comment starts
        if not in_single and not in_double and not in_backtick:
            if i + 1 < len(upper) and upper[i:i+2] == '--':
                in_line_comment = True
                i += 2
                continue
            if i + 1 < len(upper) and upper[i:i+2] == '/*':
                in_block_comment = True
                i += 2
                continue
        
        # Handle string literals
        if not in_double and not in_backtick and ch == "'":
            in_single = not in_single
            i += 1
            continue
        if not in_single and not in_backtick and ch == '"':
            in_double = not in_double
            i += 1
            continue
        if not in_single and not in_double and ch == chr(96):  # backtick
            in_backtick = not in_backtick
            i += 1
            continue
        
        if in_single or in_double or in_backtick:
            i += 1
            continue
        
        # Track parenthesis depth
        if ch == '(':
            depth += 1
            i += 1
            continue
        if ch == ')':
            if depth > 0:
                depth -= 1
            i += 1
            continue
        
        # Look for WHERE keyword at depth 0
        if depth == 0 and upper[i:i+len(keyword_where)] == keyword_where:
            # Check word boundaries
            before = upper[i-1] if i > 0 else ' '
            after = upper[i+len(keyword_where)] if i+len(keyword_where) < len(upper) else ' '
            
            if not _is_identifier_char(before) and not _is_identifier_char(after):
                clause_start = i + len(keyword_where)
                clause_end = _find_clause_end(upper, clause_start)
                if clause_end < clause_start:
                    clause_end = len(query)
                
                return True, query[clause_start:clause_end]
        
        i += 1
    
    return False, ""


def _is_identifier_char(ch: str) -> bool:
    """Check if character is part of an identifier"""
    if not ch:
        return False
    return ch.isalnum() or ch == '_'


def _find_clause_end(upper: str, start: int) -> int:
    """Find the end of a WHERE clause"""
    keywords = ['RETURNING', 'ORDER', 'GROUP', 'LIMIT', 'FOR', 'USING']
    
    in_single = False
    in_double = False
    in_backtick = False
    in_line_comment = False
    in_block_comment = False
    depth = 0
    
    i = start
    while i < len(upper):
        # Handle comments
        if in_line_comment:
            if upper[i] == '\n':
                in_line_comment = False
            i += 1
            continue
        
        if in_block_comment:
            if i + 1 < len(upper) and upper[i:i+2] == '*/':
                in_block_comment = False
                i += 2
                continue
            i += 1
            continue
        
        ch = upper[i]
        
        # Check for comment starts
        if not in_single and not in_double and not in_backtick:
            if i + 1 < len(upper) and upper[i:i+2] == '--':
                in_line_comment = True
                i += 2
                continue
            if i + 1 < len(upper) and upper[i:i+2] == '/*':
                in_block_comment = True
                i += 2
                continue
        
        # Handle string literals
        if not in_double and not in_backtick and ch == "'":
            in_single = not in_single
            i += 1
            continue
        if not in_single and not in_backtick and ch == '"':
            in_double = not in_double
            i += 1
            continue
        if not in_single and not in_double and ch == chr(96):  # backtick
            in_backtick = not in_backtick
            i += 1
            continue
        
        if in_single or in_double or in_backtick:
            i += 1
            continue
        
        # Track parenthesis depth
        if ch == '(':
            depth += 1
            i += 1
            continue
        if ch == ')':
            if depth > 0:
                depth -= 1
            i += 1
            continue
        
        # Look for clause-ending keywords at depth 0
        if depth == 0:
            for kw in keywords:
                if upper[i:i+len(kw)] == kw:
                    before = upper[i-1] if i > 0 else ' '
                    if not _is_identifier_char(before):
                        return i
        
        i += 1
    
    return len(upper)


{{- if .HasMock }}
{{ .MockData.MockLoadCode }}
{{- end }}

# ============================================================================
# Response Structures
# ============================================================================
{{- range .ResponseStructs }}

@dataclass
class {{ .ClassName }}:
    """Response structure for {{ $.FunctionName }}"""
{{- range .Fields }}
    {{ .Name }}: {{ .TypeHint }}{{ if .HasDefault }} = {{ .Default }}{{ end }}
{{- end }}
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)
{{- end }}


# ============================================================================
# Generated Functions
# ============================================================================

{{- if .HasCEL }}
# CEL Environments and Programs
{{- range .CELEnvironments }}
# Environment {{ .Index }}: {{ .Container }}
_cel_env_{{ .Index }} = None
{{- end }}

{{- range .CELPrograms }}
# Program {{ .Index }}: {{ .Expression }}
_cel_program_{{ .Index }} = None
{{- end }}

def _init_cel_programs():
    """Initialize CEL programs (called on first use)"""
    global {{ range $i, $env := .CELEnvironments }}{{ if $i }}, {{ end }}_cel_env_{{ $env.Index }}{{ end }}{{ if and (gt (len .CELEnvironments) 0) (gt (len .CELPrograms) 0) }}, {{ end }}{{ range $i, $prog := .CELPrograms }}{{ if $i }}, {{ end }}_cel_program_{{ $prog.Index }}{{ end }}
    
    if celpy is None:
        raise ImportError("celpy is required for CEL expressions. Install with: pip install celpy")
    
    {{- range $env := .CELEnvironments }}
    # Environment {{ $env.Index }}
    _cel_env_{{ $env.Index }} = celpy.Environment()
    {{- range $env.Variables }}
    _cel_env_{{ $env.Index }}.add_ident(celpy.{{ .CELType }}("{{ .Name }}"))
    {{- end }}
    {{- end }}
    
    {{- range .CELPrograms }}
    # Program {{ .Index }}
    _cel_program_{{ .Index }} = _cel_env_{{ .EnvironmentIdx }}.compile({{ .Expression | printf "%q" }})
    {{- end }}

_cel_initialized = False
{{- end }}

{{- if eq .ResponseAffinity "many" }}
async def {{ .FunctionName | snakeCase }}(
{{- if eq .Dialect "postgres" }}
    conn: asyncpg.Connection,
{{- else }}
    cursor: Any,
{{- end }}
{{- range .Parameters }}
    {{ .Name }}: {{ .TypeHint }}{{ if .HasDefault }} = {{ .Default }}{{ end }},
{{- end }}
{{- if .HasImplicitParams }}
    *,
{{- range .ImplicitParams }}
    {{ .Name }}: Optional[{{ .TypeHint }}] = None,
{{- end }}
{{- end }}
) -> AsyncGenerator[{{ .ReturnType }}, None]:
{{- else }}
async def {{ .FunctionName | snakeCase }}(
{{- if eq .Dialect "postgres" }}
    conn: asyncpg.Connection,
{{- else }}
    cursor: Any,
{{- end }}
{{- range .Parameters }}
    {{ .Name }}: {{ .TypeHint }}{{ if .HasDefault }} = {{ .Default }}{{ end }},
{{- end }}
{{- if .HasImplicitParams }}
    *,
{{- range .ImplicitParams }}
    {{ .Name }}: Optional[{{ .TypeHint }}] = None,
{{- end }}
{{- end }}
) -> {{ .ReturnType }}:
{{- end }}
    """
    {{ .Description }}
    
    Args:
{{- range .Parameters }}
        {{ .Name }}: {{ .Description }}
{{- end }}
{{- range .ImplicitParams }}
        {{ .Name }}: {{ .Description }} (optional, uses context if not provided)
{{- end }}
    
    Returns:
        {{ .ReturnTypeDescription }}
    """
{{- if .HasCEL }}
    # Initialize CEL programs on first use
    global _cel_initialized
    if not _cel_initialized:
        _init_cel_programs()
        _cel_initialized = True
{{- end }}
    
{{- if .HasImplicitParams }}
    # Get context for implicit parameters
    ctx = get_snapsql_context()
    
{{- range .ImplicitParams }}
    if {{ .Name }} is None:
        {{ .Name }} = ctx.get_system_value('{{ .Name }}')
{{- if .HasDefaultValue }}
        if {{ .Name }} is None:
            {{ .Name }} = {{ .DefaultValue }}
{{- end }}
{{- end }}
{{- end }}
    
{{- if .HasValidation }}
    # Validate required parameters
{{- range .Validations }}
    if {{ .Condition }}:
        raise ValidationError(
            message={{ .Message | printf "%q" }},
            param_name={{ .ParamName | printf "%q" }},
            func_name={{ $.FunctionName | printf "%q" }}
        )
{{- end }}
{{- end }}
    
    # Build SQL
{{- if .SQLBuilder.IsStatic }}
    sql = """{{ .SQLBuilder.StaticSQL }}"""
    args = [{{ range $i, $arg := .SQLBuilder.Args }}{{ if $i }}, {{ end }}{{ $arg }}{{ end }}]
{{- else }}
    # Dynamic SQL building
{{ .SQLBuilder.DynamicCode | indent 4 }}
{{- end }}
    
{{- if .HasMock }}
{{ .MockData.MockExecCode | indent 4 }}
{{- end }}
    
{{- if .MutationKind }}
    # WHERE clause safety check for {{ .MutationKind }}
    ctx = get_snapsql_context()
{{- if .WhereMeta }}
    where_meta = {
        'status': {{ .WhereMeta.Status | printf "%q" }},
{{- if .WhereMeta.RemovalCombos }}
        'removal_combos': [
{{- range .WhereMeta.RemovalCombos }}
            [{{ range $i, $lit := . }}{{ if $i }}, {{ end }}{'expr_index': {{ $lit.ExprIndex }}, 'when': {{ $lit.When | pythonBool }}}{{ end }}],
{{- end }}
        ],
{{- end }}
{{- if .WhereMeta.ExpressionRefs }}
        'expression_refs': [{{ range $i, $ref := .WhereMeta.ExpressionRefs }}{{ if $i }}, {{ end }}{{ $ref }}{{ end }}],
{{- end }}
{{- if .WhereMeta.DynamicConditions }}
        'dynamic_conditions': [
{{- range .WhereMeta.DynamicConditions }}
            {'expr_index': {{ .ExprIndex }}, 'negated_when_empty': {{ .NegatedWhenEmpty | pythonBool }}, 'has_else': {{ .HasElse | pythonBool }}{{ if .Description }}, 'description': {{ .Description | printf "%q" }}{{ end }}},
{{- end }}
        ],
{{- end }}
{{- if .WhereMeta.RawText }}
        'raw_text': {{ .WhereMeta.RawText | printf "%q" }},
{{- end }}
    }
    enforce_non_empty_where_clause(ctx, {{ .FunctionName | printf "%q" }}, {{ .MutationKind | mutationKindLower | printf "%q" }}, where_meta, sql)
{{- else }}
    # No WHERE metadata available
    where_meta = {'status': 'unknown'}
    enforce_non_empty_where_clause(ctx, {{ .FunctionName | printf "%q" }}, {{ .MutationKind | mutationKindLower | printf "%q" }}, where_meta, sql)
{{- end }}
{{- end }}
    
    # Execute query
{{ .QueryExecution.Code | indent 4 }}
`

// templateData represents the data passed to the Python template
type templateData struct {
	// Metadata
	Timestamp    string
	FunctionName string
	Description  string
	Dialect      string

	// Features
	HasCEL            bool
	HasImplicitParams bool
	HasValidation     bool
	HasMock           bool

	// Response structures
	ResponseStructs []responseStructData

	// CEL
	CELEnvironments []celEnvironmentData
	CELPrograms     []celProgramData

	// Parameters
	Parameters     []parameterData
	ImplicitParams []implicitParamData
	Validations    []validationData

	// SQL Building
	SQLBuilder sqlBuilderData

	// Query Execution
	QueryExecution queryExecutionData

	// Mock
	MockData mockTemplateData

	// Return type
	ReturnType            string
	ReturnTypeDescription string
	ResponseAffinity      string

	// WHERE clause safety
	MutationKind string
	WhereMeta    *whereClauseMetaData
}

// responseStructData represents a Python dataclass for responses
type responseStructData struct {
	ClassName string
	Fields    []responseFieldData
}

// responseFieldData represents a field in a response dataclass
type responseFieldData struct {
	Name       string
	TypeHint   string
	HasDefault bool
	Default    string
}

// celEnvironmentData represents a CEL environment
type celEnvironmentData struct {
	Index     int
	Container string
	Variables []celVariableData
}

// celVariableData represents a CEL variable
type celVariableData struct {
	Name    string
	CELType string // IntType, StringType, BoolType, etc.
}

// celProgramData represents a compiled CEL program
type celProgramData struct {
	Index          int
	Expression     string
	EnvironmentIdx int
}

// parameterData represents a function parameter
type parameterData struct {
	Name        string
	TypeHint    string
	Description string
	HasDefault  bool
	Default     string
}

// implicitParamData represents an implicit parameter (from context)
type implicitParamData struct {
	Name            string
	TypeHint        string
	Description     string
	HasDefaultValue bool
	DefaultValue    string
}

// validationData represents a parameter validation
type validationData struct {
	Condition string
	Message   string
	ParamName string // Parameter name for better error messages
}

// sqlBuilderData represents SQL building code
type sqlBuilderData struct {
	IsStatic       bool
	StaticSQL      string
	Args           []string
	DynamicCode    string
	CELEvaluations []celEvaluationData // CEL expressions that need to be evaluated
}

// celEvaluationData represents a CEL expression evaluation
type celEvaluationData struct {
	Index      int
	Expression string
	EnvIndex   int
}

// queryExecutionData represents query execution code
type queryExecutionData struct {
	Code string
}
