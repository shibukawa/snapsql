package pygen

import (
	"bytes"
	"strings"
	"testing"

	"github.com/shibukawa/snapsql"
	"github.com/shibukawa/snapsql/intermediate"
)

func TestGenerateBasicTemplate(t *testing.T) {
	// Create a minimal intermediate format
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetUser",
		Description:  "Get user by ID",
	}

	tests := []struct {
		name    string
		dialect string
		want    []string // strings that should be present in output
	}{
		{
			name:    "postgres dialect",
			dialect: "postgres",
			want: []string{
				"# Generated by snapsql - DO NOT EDIT",
				"import asyncpg",
				"@dataclass",
				"class SnapSQLContext:",
				"def get_snapsql_context() -> SnapSQLContext:",
				"class SnapSQLError(Exception):",
				"class NotFoundError(SnapSQLError):",
				"async def get_user(",
			},
		},
		{
			name:    "mysql dialect",
			dialect: "mysql",
			want: []string{
				"# Generated by snapsql - DO NOT EDIT",
				"import aiomysql",
				"@dataclass",
				"class SnapSQLContext:",
				"async def get_user(",
			},
		},
		{
			name:    "sqlite dialect",
			dialect: "sqlite",
			want: []string{
				"# Generated by snapsql - DO NOT EDIT",
				"import aiosqlite",
				"@dataclass",
				"class SnapSQLContext:",
				"async def get_user(",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New(format, WithDialect(snapsql.Dialect(tt.dialect)))

			var buf bytes.Buffer

			err := gen.Generate(&buf)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}

			output := buf.String()

			// Check that all expected strings are present
			for _, want := range tt.want {
				if !strings.Contains(output, want) {
					t.Errorf("Generate() output missing expected string: %q", want)
				}
			}

			// Check that output is valid Python (basic syntax check)
			if !strings.HasPrefix(output, "#") {
				t.Error("Generate() output should start with a comment")
			}
		})
	}
}

func TestGenerateWithCEL(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetFilteredUsers",
		Description:  "Get users with CEL filtering",
		CELEnvironments: []intermediate.CELEnvironment{
			{
				Index:     0,
				Container: "main",
			},
		},
		CELExpressions: []intermediate.CELExpression{
			{
				ID:               "expr_0",
				Expression:       "age > 18",
				EnvironmentIndex: 0,
			},
		},
	}

	gen := New(format, WithDialect(snapsql.DialectPostgres))

	var buf bytes.Buffer

	err := gen.Generate(&buf)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	output := buf.String()

	// Check for CEL-related code
	expectedStrings := []string{
		"import celpy",
		"_cel_env_0",
		"_cel_program_0",
		"def _init_cel_programs():",
		"_cel_initialized = False",
	}

	for _, want := range expectedStrings {
		if !strings.Contains(output, want) {
			t.Errorf("Generate() output missing CEL-related string: %q", want)
		}
	}
}

func TestGenerateContextManagement(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "InsertUser",
		Description:  "Insert a new user",
	}

	gen := New(format, WithDialect(snapsql.DialectPostgres))

	var buf bytes.Buffer

	err := gen.Generate(&buf)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	output := buf.String()

	// Check for context management code
	expectedStrings := []string{
		"@dataclass",
		"class SnapSQLContext:",
		"system_values: Dict[str, Any]",
		"enable_query_log: bool",
		"mock_mode: bool",
		"row_lock_mode: str",
		"def get_system_value(self, name: str, default: Any = None) -> Any:",
		"def set_system_value(self, name: str, value: Any) -> None:",
		"snapsql_ctx: contextvars.ContextVar[Optional[SnapSQLContext]]",
		"def get_snapsql_context() -> SnapSQLContext:",
	}

	for _, want := range expectedStrings {
		if !strings.Contains(output, want) {
			t.Errorf("Generate() output missing context management string: %q", want)
		}
	}
}

func TestGenerateErrorClasses(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetUser",
		Description:  "Get user by ID",
	}

	gen := New(format, WithDialect(snapsql.DialectPostgres))

	var buf bytes.Buffer

	err := gen.Generate(&buf)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	output := buf.String()

	// Check for error class definitions
	expectedStrings := []string{
		"class SnapSQLError(Exception):",
		"class NotFoundError(SnapSQLError):",
		"class ValidationError(SnapSQLError):",
		"class DatabaseError(SnapSQLError):",
		"class UnsafeQueryError(SnapSQLError):",
	}

	for _, want := range expectedStrings {
		if !strings.Contains(output, want) {
			t.Errorf("Generate() output missing error class: %q", want)
		}
	}
}

func TestGenerateImports(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetUser",
		Description:  "Get user by ID",
	}

	gen := New(format, WithDialect(snapsql.DialectPostgres))

	var buf bytes.Buffer

	err := gen.Generate(&buf)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	output := buf.String()

	// Check for required imports
	expectedImports := []string{
		"from dataclasses import dataclass, asdict",
		"from typing import Optional, List, Any, Dict, AsyncGenerator",
		"from datetime import datetime",
		"from decimal import Decimal",
		"import contextvars",
	}

	for _, want := range expectedImports {
		if !strings.Contains(output, want) {
			t.Errorf("Generate() output missing import: %q", want)
		}
	}
}

func TestGenerateAsyncFunction(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetUserById",
		Description:  "Get user by ID",
	}

	tests := []struct {
		name    string
		dialect string
		wantSig string
	}{
		{
			name:    "postgres uses connection",
			dialect: "postgres",
			wantSig: "async def get_user_by_id(\n    conn: asyncpg.Connection,",
		},
		{
			name:    "mysql uses cursor",
			dialect: "mysql",
			wantSig: "async def get_user_by_id(\n    cursor: Any,",
		},
		{
			name:    "sqlite uses cursor",
			dialect: "sqlite",
			wantSig: "async def get_user_by_id(\n    cursor: Any,",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New(format, WithDialect(snapsql.Dialect(tt.dialect)))

			var buf bytes.Buffer

			err := gen.Generate(&buf)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}

			output := buf.String()

			if !strings.Contains(output, tt.wantSig) {
				t.Errorf("Generate() output missing function signature: %q", tt.wantSig)
			}

			// Check for docstring
			if !strings.Contains(output, `"""`) {
				t.Error("Generate() output missing docstring")
			}
		})
	}
}
