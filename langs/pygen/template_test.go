package pygen

import (
	"bytes"
	"strings"
	"testing"

	"github.com/shibukawa/snapsql"
	"github.com/shibukawa/snapsql/intermediate"
	"github.com/shibukawa/snapsql/intermediate/codegenerator"
)

func TestGenerateBasicTemplate(t *testing.T) {
	// Create a minimal intermediate format
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetUser",
		Description:  "Get user by ID",
	}

	tests := []struct {
		name    string
		dialect snapsql.Dialect
		want    []string // strings that should be present in output
	}{
		{
			name:    "postgres dialect",
			dialect: snapsql.DialectPostgres,
			want: []string{
				"# Generated by snapsql - DO NOT EDIT",
				"import asyncpg",
				"async def get_user(",
			},
		},
		{
			name:    "mysql dialect",
			dialect: snapsql.DialectMySQL,
			want: []string{
				"# Generated by snapsql - DO NOT EDIT",
				"import aiomysql",
				"async def get_user(",
			},
		},
		{
			name:    "sqlite dialect",
			dialect: snapsql.DialectSQLite,
			want: []string{
				"# Generated by snapsql - DO NOT EDIT",
				"import aiosqlite",
				"async def get_user(",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New(format, WithDialect(tt.dialect))

			var buf bytes.Buffer

			err := gen.Generate(&buf)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}

			output := buf.String()

			// Check that all expected strings are present
			for _, want := range tt.want {
				if !strings.Contains(output, want) {
					t.Errorf("Generate() output missing expected string: %q", want)
				}
			}

			// Check that output is valid Python (basic syntax check)
			if !strings.HasPrefix(output, "#") {
				t.Error("Generate() output should start with a comment")
			}
		})
	}
}

func TestGenerateContextManagement(t *testing.T) {
	runtimeCode := renderRuntimeCode(t)

	// Check for context management code
	expectedStrings := []string{
		"@dataclass",
		"class SnapSQLContext:",
		"system_values: Dict[str, Any]",
		"enable_query_log: bool",
		"mock_mode: bool",
		"row_lock_mode: str",
		"def get_system_value(self, name: str, default: Any = None) -> Any:",
		"def set_system_value(self, name: str, value: Any) -> None:",
		"snapsql_ctx: contextvars.ContextVar[Optional[SnapSQLContext]]",
		"def get_snapsql_context() -> SnapSQLContext:",
	}

	for _, want := range expectedStrings {
		if !strings.Contains(runtimeCode, want) {
			t.Errorf("Generate() output missing context management string: %q", want)
		}
	}
}

func TestGenerateErrorClasses(t *testing.T) {
	runtimeCode := renderRuntimeCode(t)

	// Check for error class definitions
	expectedStrings := []string{
		"class SnapSQLError(Exception):",
		"class NotFoundError(SnapSQLError):",
		"class ValidationError(SnapSQLError):",
		"class DatabaseError(SnapSQLError):",
		"class UnsafeQueryError(SnapSQLError):",
	}

	for _, want := range expectedStrings {
		if !strings.Contains(runtimeCode, want) {
			t.Errorf("Generate() output missing error class: %q", want)
		}
	}
}

func TestGenerateImports(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetUser",
		Description:  "Get user by ID",
	}

	gen := New(format, WithDialect(snapsql.DialectPostgres))

	var buf bytes.Buffer

	err := gen.Generate(&buf)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	output := buf.String()

	// Check for required imports
	expectedImports := []string{
		"from dataclasses import dataclass, asdict",
		"from typing import Optional, List, Any, Dict, AsyncGenerator",
		"from datetime import datetime",
		"from decimal import Decimal",
	}

	for _, want := range expectedImports {
		if !strings.Contains(output, want) {
			t.Errorf("Generate() output missing import: %q", want)
		}
	}
}

func TestGenerateRuntimeImports(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName:     "GetUserWithContext",
		Description:      "Query that needs context and guards",
		StatementType:    "select",
		ResponseAffinity: "one",
		Parameters: []intermediate.Parameter{
			{Name: "user_id", Type: "int"},
		},
		ImplicitParameters: []intermediate.ImplicitParameter{
			{Name: "current_user_id", Type: "int"},
		},
		Responses: []intermediate.Response{
			{Name: "id", Type: "int"},
		},
	}

	gen := New(format, WithDialect(snapsql.DialectPostgres))

	var buf bytes.Buffer
	if err := gen.Generate(&buf); err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	output := buf.String()

	if !strings.Contains(output, "from .snapsql_runtime import (") {
		t.Errorf("expected runtime import block, got %q", output)
	}

	for _, symbol := range []string{"get_snapsql_context", "ValidationError", "NotFoundError"} {
		if !strings.Contains(output, symbol) {
			t.Errorf("expected runtime import %q, got %q", symbol, output)
		}
	}
}

func TestLoggingAndRowLockSections(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName:  "LockySelect",
		Description:   "Select with row lock",
		StatementType: "select",
		Instructions: []intermediate.Instruction{
			{Op: "EMIT_STATIC", Value: "SELECT 1"},
			{Op: codegenerator.OpEmitSystemFor},
		},
	}

	gen := New(format, WithDialect(snapsql.DialectPostgres))

	var buf bytes.Buffer
	if err := gen.Generate(&buf); err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	output := buf.String()

	for _, want := range []string{
		"logger = ctx.query_logger if ctx.enable_query_log else None",
		"ensure_row_lock_allowed(\"select\", ctx.row_lock_mode)",
		"row_lock_clause = build_row_lock_clause_postgres(ctx.row_lock_mode)",
		"metadata = QueryLogMetadata(",
	} {
		if !strings.Contains(output, want) {
			t.Errorf("expected logging/lock code to contain %q, got %q", want, output)
		}
	}

	if !strings.Contains(output, "ROW_LOCK_NONE") {
		t.Error("expected ROW_LOCK_NONE constant to be referenced")
	}
}

func TestGenerateAsyncFunction(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "GetUserById",
		Description:  "Get user by ID",
	}

	tests := []struct {
		name    string
		dialect snapsql.Dialect
		wantSig string
	}{
		{
			name:    "postgres uses connection",
			dialect: snapsql.DialectPostgres,
			wantSig: "async def get_user_by_id(\n    conn: asyncpg.Connection,",
		},
		{
			name:    "mysql uses cursor",
			dialect: snapsql.DialectMySQL,
			wantSig: "async def get_user_by_id(\n    cursor: Any,",
		},
		{
			name:    "sqlite uses cursor",
			dialect: snapsql.DialectSQLite,
			wantSig: "async def get_user_by_id(\n    cursor: Union[aiosqlite.cursor.Cursor, aiosqlite.Connection],",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gen := New(format, WithDialect(tt.dialect))

			var buf bytes.Buffer

			err := gen.Generate(&buf)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}

			output := buf.String()

			if !strings.Contains(output, tt.wantSig) {
				t.Errorf("Generate() output missing function signature: %q", tt.wantSig)
			}

			// Check for docstring
			if !strings.Contains(output, `"""`) {
				t.Error("Generate() output missing docstring")
			}
		})
	}
}
