package pygen

import (
	"bytes"
	"strings"
	"testing"

	"github.com/shibukawa/snapsql"
	"github.com/shibukawa/snapsql/intermediate"
)

func TestNew(t *testing.T) {
	format := &intermediate.IntermediateFormat{
		FunctionName: "get_user_by_id",
	}

	tests := []struct {
		name    string
		opts    []Option
		want    *Generator
		wantErr bool
	}{
		{
			name: "default configuration",
			opts: nil,
			want: &Generator{
				PackageName: "generated",
				Format:      format,
				Dialect:     "",
			},
			wantErr: false,
		},
		{
			name: "with package name",
			opts: []Option{WithPackageName("mypackage")},
			want: &Generator{
				PackageName: "mypackage",
				Format:      format,
				Dialect:     "",
			},
			wantErr: false,
		},
		{
			name: "with dialect",
			opts: []Option{WithDialect(snapsql.DialectPostgres)},
			want: &Generator{
				PackageName: "generated",
				Format:      format,
				Dialect:     "postgres",
			},
			wantErr: false,
		},
		{
			name: "with multiple options",
			opts: []Option{
				WithPackageName("queries"),
				WithDialect(snapsql.DialectMySQL),
				WithOutputPath("./output"),
				WithMockPath("./mocks"),
			},
			want: &Generator{
				PackageName: "queries",
				Format:      format,
				Dialect:     "mysql",
				OutputPath:  "./output",
				MockPath:    "./mocks",
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := New(format, tt.opts...)

			if got.PackageName != tt.want.PackageName {
				t.Errorf("PackageName = %v, want %v", got.PackageName, tt.want.PackageName)
			}

			if got.Dialect != tt.want.Dialect {
				t.Errorf("Dialect = %v, want %v", got.Dialect, tt.want.Dialect)
			}

			if got.OutputPath != tt.want.OutputPath {
				t.Errorf("OutputPath = %v, want %v", got.OutputPath, tt.want.OutputPath)
			}

			if got.MockPath != tt.want.MockPath {
				t.Errorf("MockPath = %v, want %v", got.MockPath, tt.want.MockPath)
			}
		})
	}
}

func TestGenerator_Generate(t *testing.T) {
	tests := []struct {
		name    string
		gen     *Generator
		wantErr bool
		errMsg  string
	}{
		{
			name: "missing dialect",
			gen: &Generator{
				PackageName: "generated",
				Format: &intermediate.IntermediateFormat{
					FunctionName: "test_func",
				},
				Dialect: "",
			},
			wantErr: true,
			errMsg:  "dialect must be specified",
		},
		{
			name: "unsupported dialect",
			gen: &Generator{
				PackageName: "generated",
				Format: &intermediate.IntermediateFormat{
					FunctionName: "test_func",
				},
				Dialect: "oracle",
			},
			wantErr: true,
			errMsg:  "unsupported dialect",
		},
		{
			name: "valid postgres dialect",
			gen: &Generator{
				PackageName: "generated",
				Format: &intermediate.IntermediateFormat{
					FunctionName: "test_func",
				},
				Dialect: "postgres",
			},
			wantErr: false,
		},
		{
			name: "valid mysql dialect",
			gen: &Generator{
				PackageName: "generated",
				Format: &intermediate.IntermediateFormat{
					FunctionName: "test_func",
				},
				Dialect: "mysql",
			},
			wantErr: false,
		},
		{
			name: "valid sqlite dialect",
			gen: &Generator{
				PackageName: "generated",
				Format: &intermediate.IntermediateFormat{
					FunctionName: "test_func",
				},
				Dialect: "sqlite",
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer

			err := tt.gen.Generate(&buf)

			if (err != nil) != tt.wantErr {
				t.Errorf("Generate() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr && err != nil {
				if !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("Generate() error = %v, want error containing %v", err, tt.errMsg)
				}
			}

			if !tt.wantErr {
				output := buf.String()
				// Verify basic structure
				if !strings.Contains(output, "# Generated by snapsql") {
					t.Errorf("Generate() output missing header")
				}

				if !strings.Contains(output, string(tt.gen.Dialect)) {
					t.Errorf("Generate() output missing dialect: %s", tt.gen.Dialect)
				}

				if !strings.Contains(output, tt.gen.Format.FunctionName) {
					t.Errorf("Generate() output missing function name: %s", tt.gen.Format.FunctionName)
				}
			}
		})
	}
}
