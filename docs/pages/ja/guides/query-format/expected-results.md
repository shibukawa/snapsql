## Expected Results（期待結果）

このページでは、テストの期待結果（Expected Results）の書式と振る舞いを実装に合わせてまとめます。特に「テーブル名を指定してテーブルの状態を検証するモード」と、`pk-match` / `pk-exists` / `pk-not-exists` のような戦略について詳述します。

### セクションヘッダの構文

テスト内の期待結果セクションは Markdown の強調（例: `**Expected Results:**`）で始まり、オプションでテーブル名と戦略を指定できます。

構文の例:

- 単純（従来の無名配列を使用）:

  **Expected Results:**

  ```yaml
  - id: 1
    name: alice
  - id: 2
    name: bob
  ```

- テーブル名 + 戦略（テーブル参照モード）:

  **Expected Results: users[pk-match]**

  以下のセクションには `users` テーブルに対する期待行を YAML/JSON で記述します。

ヘッダの解析は `markdownparser/testcase.go` の正規表現 `^([a-zA-Z_][a-zA-Z0-9_]*)(?:\[([^\]]+)\])?$` に従います。

### 外部ファイル参照

期待結果ブロックの中身を外部ファイルで参照することができます。Markdown 内では以下のようにリンク記法を使ってください。

```
[expected.yaml](path/to/expected.yaml)
```

内部実装は `\[.*?\]\((.*?)\)` を使ってリンク先を抜き出します。外部参照はテーブル付き（`Expected Results: users[pk-match]`）でも、無名期待（従来の `Expected Result`）でも使えます。

### 利用可能な戦略（strategy）

セクションで指定できる戦略は以下です（デフォルトは `all`）：

- all
  - テーブルの完全一致を検証します。実装はテーブルの全カラムを取得して（スキーマ情報があれば主キーで ORDER BY を付ける）、行数と各行の内容を比較します。
  - 比較は `compareRowsSlice` により行ごとに行われます（実装は `testrunner/fixtureexecutor/executor.go` を参照）。

- pk-match
  - 期待データに指定された主キーの組が実際に存在することを確認し、期待側に記述されたカラムに対して値（またはマッチャー）による比較を行います。
  - 期待データ内に書かれていないカラムは無視されます（部分検証モード）。
  - 主キーが定義されていないテーブルで指定するとエラーになります（`errNoPrimaryKeyDefined`）。

- pk-exists
  - 期待データに記載された主キーの組が存在することだけを検証します。その他のカラムは無視します。
  - 主キー未定義のテーブルではエラーになります。

- pk-not-exists
  - 期待データ内にある主キーの組がテーブル中に存在しないことを検証します（削除検証などに利用）。
  - 主キー未定義のテーブルではエラーになります。

実装上、`pk-*` 系の戦略はまずテーブルスキーマから主キー列を取得します。

### マッチャー（値比較の特殊指定）

期待値セルにはマッチャーを指定できます。内部的には期待値が配列（`[]any`）として扱われ、先頭要素がマッチャー名として解釈されます。実装では `compareRowsWithMatchers` / `evaluateMatcherDiff` がこれらを評価します。

主なマッチャーと挙動:

- `[null]` / `"null"`
  - 実際の値が NULL（Go の `nil`）であることを期待します。

- `[notnull]` / `"notnull"`
  - 実際の値が NULL でないことを期待します。

- `[any]`
  - 任意の値を許容します。フィールドの存在だけ確認したい場合に有効です（NULL の扱いはプロジェクト方針に依存する点に注意）。

- `[currentdate, "<duration>"]` / `[current_date, "<duration>"]`
  - 値が日時であり、現在時刻との差が指定した許容時間内であることを検証します。`<duration>` は `time.ParseDuration` 準拠（`"1m"`, `"30s"` 等）。指定がない場合のデフォルトは短時間（通常 1 分）です。

- `[regexp, "<pattern>"]` / `[regexp, '^pattern$']`
  - 値が文字列で、指定した Go の正規表現にマッチするかを検証します。

実装上の一般ルール:

- NULL 判定は厳密（`nil` 同士のみ等価で、DBUnitのように文字列解釈ルールを設定して対応したりはしない）。
- 数値は内部で float64 に正規化して比較するため、`1` と `1.0` は等価と見なされます。絶対誤差は小さな閾値（例: 1e-9）で判定されます。
- DB ドライバにより `TEXT` が `[]byte` として返るケースを吸収し、`string` と `[]byte` を等価に扱う実装があります。
- 時刻は複数のレイアウトでパース可能にしておき、時刻オブジェクト同士で比較します。タイムゾーン差や短時間の遅延を吸収するため、`[currentdate]` 等は許容幅を持たせるのが一般的です。

ベストプラクティス（アサーション方針）:

- 固定値はリテラルで明示する（例: `name: "alice"`）。
- 可変値（時刻、UUID、トークン等）はマッチャーを使う。
- 存在チェックは `[any]` / `[notnull]` を使う。
- 複雑な正規表現はテストの可読性と安定性を下げるため、なるべく単純なパターンを用いるか事前検証を推奨します。

### 無名期待結果（従来互換）との違い

従来の無名配列（`Expected Results:` ブロックに配列を直接書く）は、クエリの戻り値（SELECT / RETURNING）をそのまま比較する用途に向きます。一方、テーブル名を指定するモード（例: `Expected Results: users[pk-match]`）は、データベース上のテーブルの状態を直接フェッチして比較します。これにより DML の副作用を検証できる点が異なります。

実装上、テーブル参照モードが指定されると、内部で `SELECT <all cols> FROM <table> ORDER BY <pk...>` を実行して比較します。

### エラーパターンと注意点

- `pk-*` 戦略を使う場合、そのテーブルに主キーが定義されている必要があります。主キーがないと `errNoPrimaryKeyDefined` 相当のエラーになります。
- `pk-match` は期待行に書かれていない列を無視します。すなわち、期待データは部分的にカラムを指定して差分検証する用途に適しています。
- 外部ファイル参照のフォーマットが不正な場合、パーサは `ErrInvalidExpectedResultsExternalLinkFormat` を返します。リンクは `[...] (path)` 形式で、正規表現 `\[.*?\]\((.*?)\)` で抽出されます。

### 具体例

- pk-match（部分検証）

  **Expected Results: users[pk-match]**

  ```yaml
  - id: 42
    name: ["regexp", "^Alice.*"]
    updated_at: ["currentdate", "2m"]
  ```

  説明: `id` を主キーとしてレコードが存在することを確認し、`name` と `updated_at` は期待値（マッチャー）に従って検証します。他のカラムは無視されます。

- pk-exists（存在確認）

  **Expected Results: users[pk-exists]**

  ```yaml
  - id: 100
  - id: 101
  ```

  説明: `id=100` と `id=101` の PK が存在することだけを確認します。

- pk-not-exists（削除確認）

  **Expected Results: users[pk-not-exists]**

  ```yaml
  - id: 5
  ```

  説明: `id=5` の主キー組がテーブルに存在しないことを確認します。

- テーブル完全比較（all）

  **Expected Results: users[all]**

  ```yaml
  - id: 1
    name: alice
  - id: 2
    name: bob
  ```

  説明: テーブル全体の行数と内容が一致することを期待します（主キーがあれば ORDER BY による安定ソートが行われます）。
