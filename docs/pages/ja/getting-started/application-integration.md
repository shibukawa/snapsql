# Application Integration

生成されたコードをアプリケーションに統合する方法について説明します。

## プロジェクト構造

生成コードを統合したプロジェクト構造：

```
myapp/
├── cmd/
│   └── main.go          # アプリケーションエントリーポイント
├── internal/
│   ├── database/
│   │   └── connection.go # DB接続管理
│   └── client/          # 生成されたクライアントコード
│       └── client.go
├── web/
│   ├── handlers/
│   │   └── tasks.go     # HTTPハンドラー
│   └── templates/
└── go.mod
```

## データベース接続の設定

`internal/database/connection.go`:

```go
package database

import (
    "database/sql"
    "fmt"
    "os"
    
    _ "github.com/lib/pq"      // PostgreSQL
    _ "github.com/go-sql-driver/mysql" // MySQL
    _ "github.com/mattn/go-sqlite3"    // SQLite
)

type Config struct {
    Driver   string
    Host     string
    Port     string
    User     string
    Password string
    DBName   string
    SSLMode  string
}

func NewConfig() *Config {
    return &Config{
        Driver:   getEnv("DB_DRIVER", "postgres"),
        Host:     getEnv("DB_HOST", "localhost"),
        Port:     getEnv("DB_PORT", "5432"),
        User:     getEnv("DB_USER", "postgres"),
        Password: getEnv("DB_PASSWORD", "password"),
        DBName:   getEnv("DB_NAME", "myapp"),
        SSLMode:  getEnv("DB_SSLMODE", "disable"),
    }
}

func (c *Config) DSN() string {
    switch c.Driver {
    case "postgres":
        return fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=%s",
            c.User, c.Password, c.Host, c.Port, c.DBName, c.SSLMode)
    case "mysql":
        return fmt.Sprintf("%s:%s@tcp(%s:%s)/%s",
            c.User, c.Password, c.Host, c.Port, c.DBName)
    case "sqlite":
        return fmt.Sprintf("file:%s", c.DBName)
    default:
        return ""
    }
}

func Connect(config *Config) (*sql.DB, error) {
    db, err := sql.Open(config.Driver, config.DSN())
    if err != nil {
        return nil, err
    }
    
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    // コネクションプール設定
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(25)
    
    return db, nil
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}
```

## クライアントの初期化

`internal/client/client.go` (生成されたコードを配置):

```go
// Code generated by snapsql. DO NOT EDIT.

package client

import (
    "context"
    "database/sql"
)

type Client struct {
    db *sql.DB
}

func New(db *sql.DB) *Client {
    return &Client{db: db}
}

// 生成されたメソッド...
func (c *Client) GetProjectTasks(ctx context.Context, projectID int) ([]ProjectTask, error) {
    // 実装...
}
```

## HTTPハンドラーの実装

`web/handlers/tasks.go`:

```go
package handlers

import (
    "encoding/json"
    "net/http"
    "strconv"
    
    "myapp/internal/client"
)

type TaskHandler struct {
    client *client.Client
}

func NewTaskHandler(client *client.Client) *TaskHandler {
    return &TaskHandler{client: client}
}

func (h *TaskHandler) GetProjectTasks(w http.ResponseWriter, r *http.Request) {
    // パラメータ取得
    projectIDStr := r.URL.Query().Get("project_id")
    projectID, err := strconv.Atoi(projectIDStr)
    if err != nil {
        http.Error(w, "Invalid project_id", http.StatusBadRequest)
        return
    }
    
    // クエリ実行
    tasks, err := h.client.GetProjectTasks(r.Context(), projectID)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // JSONレスポンス
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "tasks": tasks,
    })
}
```

## メインアプリケーション

`cmd/main.go`:

```go
package main

import (
    "log"
    "net/http"
    
    "myapp/internal/client"
    "myapp/internal/database"
    "myapp/web/handlers"
)

func main() {
    // データベース接続
    config := database.NewConfig()
    db, err := database.Connect(config)
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    defer db.Close()
    
    // クライアント初期化
    client := client.New(db)
    
    // ハンドラー初期化
    taskHandler := handlers.NewTaskHandler(client)
    
    // ルーティング
    http.HandleFunc("/api/projects/", taskHandler.GetProjectTasks)
    
    // サーバー起動
    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

## ミドルウェアの統合

### ロギング

```go
func LoggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next(w, r)
        log.Printf("%s %s %v", r.Method, r.URL.Path, time.Since(start))
    }
}

// 使用
http.HandleFunc("/api/projects/", LoggingMiddleware(taskHandler.GetProjectTasks))
```

### エラーハンドリング

```go
func (h *TaskHandler) handleError(w http.ResponseWriter, err error, status int) {
    log.Printf("Error: %v", err)
    http.Error(w, "Internal Server Error", status)
}
```

## テストとの統合

生成されたコードはテスト済みなので、統合テストに集中：

```go
func TestGetProjectTasksIntegration(t *testing.T) {
    // データベースセットアップ
    db := setupTestDB(t)
    defer db.Close()
    
    // クライアント作成
    client := client.New(db)
    
    // テストデータ投入
    setupTestData(t, db)
    
    // APIテスト
    req := httptest.NewRequest("GET", "/api/projects/1/tasks", nil)
    w := httptest.NewRecorder()
    
    handler := handlers.NewTaskHandler(client)
    handler.GetProjectTasks(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    
    tasks := response["tasks"].([]interface{})
    assert.Greater(t, len(tasks), 0)
}
```

## パフォーマンス最適化

### コネクションプーリング

適切なコネクションプール設定：

```go
db.SetMaxOpenConns(25)
db.SetMaxIdleConns(25)
db.SetConnMaxLifetime(time.Hour)
```

### クエリ最適化

生成されたコードはすでに最適化されていますが、必要に応じて：

- インデックスの追加
- クエリのチューニング
- キャッシュの導入

## 次のステップ

これでSnapSQLのGetting Startedチュートリアルは完了です！

## 関連セクション

* [生成コードの使い方（Go）](../guides/language-reference/go.md)
* [トランザクションと実行オプション](../guides/user-reference/transactions.md)
* [方言とデータ型の注意点](../guides/user-reference/dialects.md)